---
description: "Comprehensive Ink React CLI framework standards with component-based CLI development, user interaction patterns, and modern CLI UX following expert Ink best practices"
globs: ["**/*.{js,ts,jsx,tsx,mjs,cjs}", "**/cli/**/*.{js,ts,jsx,tsx}", "**/bin/**/*.{js,ts,jsx,tsx}", "**/*.json"]
alwaysApply: false
---

<rule>
  <meta>
    <title>Ink React CLI Framework Standards</title>
    <description>Comprehensive Ink React CLI framework standards with component-based CLI development, user interaction patterns, and modern CLI UX following expert Ink best practices</description>
    <created-at utc-timestamp="1744245220">January 27, 2025, 11:40 AM</created-at>
    <last-updated-at utc-timestamp="1744245220">January 27, 2025, 11:40 AM</last-updated-at>
    <applies-to>
      <file-matcher glob="**/*.{js,ts,jsx,tsx,mjs,cjs}">JavaScript and TypeScript files using Ink</file-matcher>
      <file-matcher glob="**/cli/**/*.{js,ts,jsx,tsx}">CLI applications and command-line interfaces</file-matcher>
      <file-matcher glob="**/bin/**/*.{js,ts,jsx,tsx}">Binary/executable CLI tools</file-matcher>
      <action-matcher action="cli-development">Triggered when developing CLI applications with React-based UIs</action-matcher>
    </applies-to>
  </meta>

  <requirements>
    <non-negotiable priority="critical">
      <description>Use Ink with React functional components and hooks for building interactive CLI applications with proper component lifecycle management and state handling.</description>
      <examples>
        <example title="React-Based CLI Component Architecture">
          <correct-example title="Proper Ink component structure with hooks" conditions="Building CLI applications with Ink" expected-result="Well-structured CLI with React patterns" correctness-criteria="Uses functional components, hooks, proper state management, clean component hierarchy">#!/usr/bin/env node
import React, { useState, useEffect, useCallback } from 'react';
import { render, Box, Text, useInput, useApp, useFocus } from 'ink';
import { Command } from 'commander';
import chalk from 'chalk';

// TypeScript interfaces for strong typing
interface AppProps {
  name?: string;
  verbose?: boolean;
  config?: string;
}

interface TaskStatus {
  id: string;
  name: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  progress?: number;
  duration?: number;
}

interface AppState {
  tasks: TaskStatus[];
  selectedTask: number;
  isRunning: boolean;
  currentView: 'main' | 'settings' | 'help';
}

// Custom hooks for CLI-specific logic
const useTaskManager = () => {
  const [tasks, setTasks] = useState<TaskStatus[]>([]);
  const [isRunning, setIsRunning] = useState(false);

  const addTask = useCallback((name: string) => {
    const newTask: TaskStatus = {
      id: `task-${Date.now()}`,
      name,
      status: 'pending'
    };
    setTasks(prev => [...prev, newTask]);
    return newTask.id;
  }, []);

  const updateTask = useCallback((id: string, updates: Partial<TaskStatus>) => {
    setTasks(prev => prev.map(task => 
      task.id === id ? { ...task, ...updates } : task
    ));
  }, []);

  const runTask = useCallback(async (id: string) => {
    setIsRunning(true);
    updateTask(id, { status: 'running' });
    
    try {
      // Simulate task execution with progress
      for (let progress = 0; progress <= 100; progress += 10) {
        updateTask(id, { progress });
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      updateTask(id, { status: 'completed', progress: 100 });
    } catch (error) {
      updateTask(id, { status: 'failed' });
    } finally {
      setIsRunning(false);
    }
  }, [updateTask]);

  return { tasks, isRunning, addTask, updateTask, runTask };
};

// Progress indicator component
const ProgressBar: React.FC<{ progress: number; width?: number }> = ({ 
  progress, 
  width = 20 
}) => {
  const filledWidth = Math.round((progress / 100) * width);
  const emptyWidth = width - filledWidth;
  
  return (
    <Box>
      <Text color="green">{'‚ñà'.repeat(filledWidth)}</Text>
      <Text color="gray">{'‚ñë'.repeat(emptyWidth)}</Text>
      <Text> {progress}%</Text>
    </Box>
  );
};

// Task list component with focus management
const TaskList: React.FC<{
  tasks: TaskStatus[];
  selectedIndex: number;
  onSelect: (index: number) => void;
  onRun: (taskId: string) => void;
}> = ({ tasks, selectedIndex, onSelect, onRun }) => {
  const { isFocused } = useFocus();

  useInput((input, key) => {
    if (!isFocused) return;

    if (key.upArrow) {
      onSelect(Math.max(0, selectedIndex - 1));
    } else if (key.downArrow) {
      onSelect(Math.min(tasks.length - 1, selectedIndex + 1));
    } else if (key.return) {
      const selectedTask = tasks[selectedIndex];
      if (selectedTask && selectedTask.status === 'pending') {
        onRun(selectedTask.id);
      }
    }
  });

  return (
    <Box flexDirection="column">
      <Text bold color="blue">Tasks:</Text>
      {tasks.map((task, index) => (
        <Box key={task.id} marginY={0}>
          <Text color={index === selectedIndex ? 'cyan' : 'white'}>
            {index === selectedIndex ? '‚ñ∂ ' : '  '}
          </Text>
          <Text color={getStatusColor(task.status)}>
            {getStatusIcon(task.status)} {task.name}
          </Text>
          {task.status === 'running' && task.progress !== undefined && (
            <Box marginLeft={2}>
              <ProgressBar progress={task.progress} />
            </Box>
          )}
        </Box>
      ))}
    </Box>
  );
};

// Status indicator helpers
const getStatusColor = (status: TaskStatus['status']) => {
  switch (status) {
    case 'pending': return 'yellow';
    case 'running': return 'blue';
    case 'completed': return 'green';
    case 'failed': return 'red';
    default: return 'white';
  }
};

const getStatusIcon = (status: TaskStatus['status']) => {
  switch (status) {
    case 'pending': return '‚è≥';
    case 'running': return 'üîÑ';
    case 'completed': return '‚úÖ';
    case 'failed': return '‚ùå';
    default: return '‚ö™';
  }
};

// Help component
const HelpView: React.FC<{ onBack: () => void }> = ({ onBack }) => {
  const { isFocused } = useFocus();

  useInput((input, key) => {
    if (!isFocused) return;
    if (key.escape || input === 'q') {
      onBack();
    }
  });

  return (
    <Box flexDirection="column" padding={1}>
      <Text bold color="cyan">Help - Keyboard Shortcuts</Text>
      <Text>‚Üë/‚Üì - Navigate tasks</Text>
      <Text>Enter - Run selected task</Text>
      <Text>h - Show/hide help</Text>
      <Text>s - Settings</Text>
      <Text>q/Esc - Quit/Back</Text>
      <Text color="gray">Press 'q' or Esc to go back</Text>
    </Box>
  );
};

// Settings component
const SettingsView: React.FC<{ onBack: () => void }> = ({ onBack }) => {
  const [config, setConfig] = useState({
    autoRefresh: true,
    showProgress: true,
    theme: 'dark'
  });
  const { isFocused } = useFocus();

  useInput((input, key) => {
    if (!isFocused) return;
    if (key.escape || input === 'q') {
      onBack();
    }
  });

  return (
    <Box flexDirection="column" padding={1}>
      <Text bold color="cyan">Settings</Text>
      <Text>Auto Refresh: {config.autoRefresh ? '‚úÖ' : '‚ùå'}</Text>
      <Text>Show Progress: {config.showProgress ? '‚úÖ' : '‚ùå'}</Text>
      <Text>Theme: {config.theme}</Text>
      <Text color="gray">Press 'q' or Esc to go back</Text>
    </Box>
  );
};

// Main application component
const TaskManagerApp: React.FC<AppProps> = ({ name = 'Task Manager', verbose }) => {
  const { exit } = useApp();
  const { tasks, isRunning, addTask, runTask } = useTaskManager();
  const [selectedTask, setSelectedTask] = useState(0);
  const [currentView, setCurrentView] = useState<'main' | 'settings' | 'help'>('main');

  // Global input handling
  useInput((input, key) => {
    if (currentView !== 'main') return;

    if (input === 'q' || key.escape) {
      exit();
    } else if (input === 'h') {
      setCurrentView('help');
    } else if (input === 's') {
      setCurrentView('settings');
    } else if (input === 'a') {
      addTask(`New Task ${tasks.length + 1}`);
    }
  });

  // Initialize with sample tasks
  useEffect(() => {
    if (tasks.length === 0) {
      addTask('Setup project');
      addTask('Install dependencies');
      addTask('Run tests');
      addTask('Build application');
    }
  }, [tasks.length, addTask]);

  // Render different views
  const renderCurrentView = () => {
    switch (currentView) {
      case 'help':
        return <HelpView onBack={() => setCurrentView('main')} />;
      case 'settings':
        return <SettingsView onBack={() => setCurrentView('main')} />;
      default:
        return (
          <Box flexDirection="column">
            <TaskList
              tasks={tasks}
              selectedIndex={selectedTask}
              onSelect={setSelectedTask}
              onRun={runTask}
            />
            <Box marginTop={1}>
              <Text color="gray">
                Controls: ‚Üë/‚Üì Navigate | Enter Run | 'a' Add | 'h' Help | 'q' Quit
              </Text>
            </Box>
            {isRunning && (
              <Box marginTop={1}>
                <Text color="blue">‚ö° Task running...</Text>
              </Box>
            )}
          </Box>
        );
    }
  };

  return (
    <Box flexDirection="column" padding={1}>
      <Text bold color="magenta">{name}</Text>
      <Text color="gray">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</Text>
      {renderCurrentView()}
    </Box>
  );
};

// CLI setup with Commander.js
const program = new Command();

program
  .name('task-manager')
  .description('Interactive task manager CLI built with Ink')
  .version('1.0.0')
  .option('-n, --name <name>', 'application name', 'Task Manager')
  .option('-v, --verbose', 'verbose output', false)
  .option('-c, --config <path>', 'config file path')
  .action((options) => {
    // Validate options
    if (options.config && !require('fs').existsSync(options.config)) {
      console.error(chalk.red(`Config file not found: ${options.config}`));
      process.exit(1);
    }

    // Render the Ink app
    render(<TaskManagerApp {...options} />);
  });

// Error handling
process.on('unhandledRejection', (error) => {
  console.error(chalk.red('Unhandled promise rejection:'), error);
  process.exit(1);
});

process.on('uncaughtException', (error) => {
  console.error(chalk.red('Uncaught exception:'), error);
  process.exit(1);
});

// Parse CLI arguments
program.parse();</correct-example>
          <incorrect-example title="Poor Ink usage with class components and manual DOM" conditions="Building CLI applications with Ink" expected-result="Well-structured CLI with React patterns" incorrectness-criteria="Uses class components, manual DOM manipulation, no hooks, poor state management">const React = require('react');
const { render, Box, Text } = require('ink');

// Bad: Class component instead of functional component
class BadTaskManager extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      tasks: [],
      currentTask: 0
    };
  }
  
  // Bad: No useInput hook, manual event handling
  componentDidMount() {
    process.stdin.on('keypress', (ch, key) => {
      // Bad: Manual key handling without Ink's useInput
      if (key.name === 'up') {
        this.setState({ currentTask: this.state.currentTask - 1 });
      }
    });
  }
  
  // Bad: No proper cleanup
  componentWillUnmount() {
    // Missing cleanup
  }
  
  render() {
    // Bad: No component composition
    return React.createElement('div', null, 
      'Tasks: ' + this.state.tasks.length
    );
  }
}

// Bad: Direct DOM manipulation in CLI
const badRender = () => {
  console.clear();
  console.log('Tasks:');
  // Bad: Manual console output instead of Ink components
};

// Bad: No error handling
render(React.createElement(BadTaskManager));</incorrect-example>
        </example>
      </examples>
    </non-negotiable>

    <non-negotiable priority="critical">
      <description>Implement proper input handling and user interaction patterns using Ink's useInput hook with keyboard navigation, shortcuts, and accessibility considerations.</description>
      <examples>
        <example title="Advanced Input Handling and User Interaction">
          <correct-example title="Comprehensive input handling with accessibility" conditions="Handling user input in CLI applications" expected-result="Responsive and accessible CLI interactions" correctness-criteria="Uses useInput hook, handles all input types, provides clear feedback, supports accessibility">import React, { useState, useCallback } from 'react';
import { Box, Text, useInput, useFocus } from 'ink';

// Input handling types
interface KeyBinding {
  key: string;
  description: string;
  action: () => void;
  modifier?: 'ctrl' | 'alt' | 'shift';
  category?: 'navigation' | 'action' | 'global';
}

interface InputState {
  mode: 'normal' | 'insert' | 'command';
  buffer: string;
  cursorPosition: number;
  history: string[];
  historyIndex: number;
}

// Custom hook for complex input handling
const useAdvancedInput = (initialMode: 'normal' | 'insert' | 'command' = 'normal') => {
  const [inputState, setInputState] = useState<InputState>({
    mode: initialMode,
    buffer: '',
    cursorPosition: 0,
    history: [],
    historyIndex: -1
  });

  const addToHistory = useCallback((command: string) => {
    if (command.trim()) {
      setInputState(prev => ({
        ...prev,
        history: [...prev.history, command],
        historyIndex: -1,
        buffer: ''
      }));
    }
  }, []);

  const navigateHistory = useCallback((direction: 'up' | 'down') => {
    setInputState(prev => {
      const newIndex = direction === 'up' 
        ? Math.max(-1, prev.historyIndex - 1)
        : Math.min(prev.history.length - 1, prev.historyIndex + 1);
      
      const newBuffer = newIndex === -1 
        ? '' 
        : prev.history[prev.history.length - 1 - newIndex];

      return {
        ...prev,
        historyIndex: newIndex,
        buffer: newBuffer,
        cursorPosition: newBuffer.length
      };
    });
  }, []);

  const updateBuffer = useCallback((newBuffer: string, cursorPos?: number) => {
    setInputState(prev => ({
      ...prev,
      buffer: newBuffer,
      cursorPosition: cursorPos ?? newBuffer.length
    }));
  }, []);

  const setMode = useCallback((mode: InputState['mode']) => {
    setInputState(prev => ({ ...prev, mode }));
  }, []);

  return {
    inputState,
    addToHistory,
    navigateHistory,
    updateBuffer,
    setMode
  };
};

// Command input component with vi-like bindings
const CommandInput: React.FC<{
  onCommand: (command: string) => void;
  onCancel: () => void;
  placeholder?: string;
}> = ({ onCommand, onCancel, placeholder = 'Enter command...' }) => {
  const { inputState, addToHistory, navigateHistory, updateBuffer, setMode } = useAdvancedInput('insert');
  const { isFocused } = useFocus();

  useInput((input, key) => {
    if (!isFocused) return;

    // Handle special keys
    if (key.escape) {
      setMode('normal');
      onCancel();
      return;
    }

    if (key.return) {
      if (inputState.buffer.trim()) {
        addToHistory(inputState.buffer);
        onCommand(inputState.buffer.trim());
      }
      return;
    }

    // History navigation
    if (key.upArrow) {
      navigateHistory('up');
      return;
    }

    if (key.downArrow) {
      navigateHistory('down');
      return;
    }

    // Cursor movement
    if (key.leftArrow) {
      setInputState(prev => ({
        ...prev,
        cursorPosition: Math.max(0, prev.cursorPosition - 1)
      }));
      return;
    }

    if (key.rightArrow) {
      setInputState(prev => ({
        ...prev,
        cursorPosition: Math.min(prev.buffer.length, prev.cursorPosition + 1)
      }));
      return;
    }

    // Text editing
    if (key.backspace) {
      if (inputState.cursorPosition > 0) {
        const newBuffer = 
          inputState.buffer.slice(0, inputState.cursorPosition - 1) +
          inputState.buffer.slice(inputState.cursorPosition);
        updateBuffer(newBuffer, inputState.cursorPosition - 1);
      }
      return;
    }

    if (key.delete) {
      if (inputState.cursorPosition < inputState.buffer.length) {
        const newBuffer = 
          inputState.buffer.slice(0, inputState.cursorPosition) +
          inputState.buffer.slice(inputState.cursorPosition + 1);
        updateBuffer(newBuffer);
      }
      return;
    }

    // Word movement (Ctrl+Arrow)
    if (key.ctrl && key.leftArrow) {
      // Move to beginning of word
      let pos = inputState.cursorPosition - 1;
      while (pos > 0 && inputState.buffer[pos] === ' ') pos--;
      while (pos > 0 && inputState.buffer[pos] !== ' ') pos--;
      updateBuffer(inputState.buffer, Math.max(0, pos));
      return;
    }

    // Regular character input
    if (input && !key.ctrl && !key.meta) {
      const newBuffer = 
        inputState.buffer.slice(0, inputState.cursorPosition) +
        input +
        inputState.buffer.slice(inputState.cursorPosition);
      updateBuffer(newBuffer, inputState.cursorPosition + 1);
    }
  });

  return (
    <Box>
      <Text color="cyan">{'> '}</Text>
      <Text>
        {inputState.buffer.slice(0, inputState.cursorPosition)}
        <Text backgroundColor="white" color="black">
          {inputState.buffer[inputState.cursorPosition] || ' '}
        </Text>
        {inputState.buffer.slice(inputState.cursorPosition + 1)}
      </Text>
      {!inputState.buffer && (
        <Text color="gray">{placeholder}</Text>
      )}
    </Box>
  );
};

// Navigation menu with keyboard shortcuts
const NavigationMenu: React.FC<{
  items: Array<{ label: string; key: string; action: () => void; disabled?: boolean }>;
  selectedIndex: number;
  onSelect: (index: number) => void;
}> = ({ items, selectedIndex, onSelect }) => {
  const { isFocused } = useFocus();

  useInput((input, key) => {
    if (!isFocused) return;

    // Arrow key navigation
    if (key.upArrow) {
      const newIndex = selectedIndex > 0 ? selectedIndex - 1 : items.length - 1;
      onSelect(newIndex);
    } else if (key.downArrow) {
      const newIndex = selectedIndex < items.length - 1 ? selectedIndex + 1 : 0;
      onSelect(newIndex);
    } else if (key.return || input === ' ') {
      const selectedItem = items[selectedIndex];
      if (selectedItem && !selectedItem.disabled) {
        selectedItem.action();
      }
    }

    // Direct key shortcuts
    const shortcutItem = items.find(item => 
      item.key.toLowerCase() === input?.toLowerCase()
    );
    if (shortcutItem && !shortcutItem.disabled) {
      shortcutItem.action();
    }
  });

  return (
    <Box flexDirection="column">
      {items.map((item, index) => (
        <Box key={item.label}>
          <Text color={index === selectedIndex ? 'cyan' : 'white'}>
            {index === selectedIndex ? '‚ñ∂ ' : '  '}
          </Text>
          <Text 
            color={item.disabled ? 'gray' : 'white'}
            strikethrough={item.disabled}
          >
            [{item.key}] {item.label}
          </Text>
        </Box>
      ))}
    </Box>
  );
};

// Accessible form component
const AccessibleForm: React.FC<{
  fields: Array<{
    name: string;
    label: string;
    type: 'text' | 'number' | 'select' | 'checkbox';
    options?: string[];
    required?: boolean;
    validation?: (value: string) => string | null;
  }>;
  onSubmit: (data: Record<string, any>) => void;
  onCancel: () => void;
}> = ({ fields, onSubmit, onCancel }) => {
  const [currentField, setCurrentField] = useState(0);
  const [formData, setFormData] = useState<Record<string, any>>({});
  const [errors, setErrors] = useState<Record<string, string>>({});
  const { isFocused } = useFocus();

  const validateField = (fieldName: string, value: any) => {
    const field = fields.find(f => f.name === fieldName);
    if (!field) return null;

    if (field.required && (!value || value.toString().trim() === '')) {
      return `${field.label} is required`;
    }

    if (field.validation) {
      return field.validation(value);
    }

    return null;
  };

  const handleSubmit = () => {
    const newErrors: Record<string, string> = {};
    
    fields.forEach(field => {
      const error = validateField(field.name, formData[field.name]);
      if (error) {
        newErrors[field.name] = error;
      }
    });

    setErrors(newErrors);

    if (Object.keys(newErrors).length === 0) {
      onSubmit(formData);
    }
  };

  useInput((input, key) => {
    if (!isFocused) return;

    if (key.escape) {
      onCancel();
      return;
    }

    if (key.tab || key.downArrow) {
      setCurrentField(prev => (prev + 1) % fields.length);
      return;
    }

    if (key.upArrow) {
      setCurrentField(prev => prev > 0 ? prev - 1 : fields.length - 1);
      return;
    }

    if (key.return) {
      if (currentField === fields.length - 1) {
        handleSubmit();
      } else {
        setCurrentField(prev => prev + 1);
      }
      return;
    }

    // Handle field-specific input
    const currentFieldDef = fields[currentField];
    if (!currentFieldDef) return;

    const currentValue = formData[currentFieldDef.name] || '';

    if (currentFieldDef.type === 'checkbox') {
      if (input === ' ') {
        setFormData(prev => ({
          ...prev,
          [currentFieldDef.name]: !prev[currentFieldDef.name]
        }));
      }
    } else if (currentFieldDef.type === 'select') {
      if (key.leftArrow || key.rightArrow) {
        const options = currentFieldDef.options || [];
        const currentIndex = options.indexOf(currentValue);
        const newIndex = key.leftArrow 
          ? Math.max(0, currentIndex - 1)
          : Math.min(options.length - 1, currentIndex + 1);
        
        setFormData(prev => ({
          ...prev,
          [currentFieldDef.name]: options[newIndex]
        }));
      }
    } else {
      // Text/number input
      if (key.backspace) {
        setFormData(prev => ({
          ...prev,
          [currentFieldDef.name]: currentValue.slice(0, -1)
        }));
      } else if (input && !key.ctrl && !key.meta) {
        setFormData(prev => ({
          ...prev,
          [currentFieldDef.name]: currentValue + input
        }));
      }
    }
  });

  return (
    <Box flexDirection="column">
      <Text bold color="blue">Form</Text>
      {fields.map((field, index) => (
        <Box key={field.name} flexDirection="column" marginY={0}>
          <Box>
            <Text color={index === currentField ? 'cyan' : 'white'}>
              {index === currentField ? '‚ñ∂ ' : '  '}
              {field.label}
              {field.required && <Text color="red">*</Text>}:
            </Text>
          </Box>
          <Box marginLeft={2}>
            {field.type === 'checkbox' ? (
              <Text>[{formData[field.name] ? '‚úì' : ' '}] Use space to toggle</Text>
            ) : field.type === 'select' ? (
              <Text>{formData[field.name] || field.options?.[0] || ''} (‚Üê/‚Üí to change)</Text>
            ) : (
              <Text backgroundColor={index === currentField ? 'blue' : undefined}>
                {formData[field.name] || ''}
                {index === currentField && <Text>|</Text>}
              </Text>
            )}
          </Box>
          {errors[field.name] && (
            <Box marginLeft={2}>
              <Text color="red">‚ö† {errors[field.name]}</Text>
            </Box>
          )}
        </Box>
      ))}
      <Box marginTop={1}>
        <Text color="gray">
          Tab/‚Üë‚Üì: Navigate | Enter: Next/Submit | Esc: Cancel
        </Text>
      </Box>
    </Box>
  );
};

export { CommandInput, NavigationMenu, AccessibleForm, useAdvancedInput };</correct-example>
          <incorrect-example title="Poor input handling without hooks" conditions="Handling user input in CLI applications" expected-result="Responsive and accessible CLI interactions" incorrectness-criteria="No useInput hook, poor keyboard handling, no accessibility, manual event listeners">const React = require('react');
const { Box, Text } = require('ink');

// Bad: Manual input handling without useInput
class BadInputHandler extends React.Component {
  componentDidMount() {
    // Bad: Manual process.stdin handling
    process.stdin.setRawMode(true);
    process.stdin.on('data', (data) => {
      // Bad: Manual key parsing
      const key = data.toString();
      if (key === '\u0003') {
        process.exit(0);
      }
      // Bad: No proper state management
      console.log('Key pressed:', key);
    });
  }

  render() {
    // Bad: No interactive components
    return React.createElement(Box, null, 
      React.createElement(Text, null, 'Press any key')
    );
  }
}

// Bad: No accessibility considerations
const BadMenu = () => {
  // Bad: No useInput, no focus management
  return (
    <Box>
      <Text>1. Option 1</Text>
      <Text>2. Option 2</Text>
      // Bad: No keyboard navigation
    </Box>
  );
};

// Bad: No input validation or error handling
const BadForm = () => {
  let input = '';
  
  // Bad: Global variable instead of state
  process.stdin.on('keypress', (ch, key) => {
    // Bad: No validation, no error handling
    input += ch;
  });
  
  return <Text>{input}</Text>;
};</incorrect-example>
        </example>
      </examples>
    </non-negotiable>

    <non-negotiable priority="critical">
      <description>Use Ink's layout components (Box, Text, Newline, Spacer) with proper Flexbox patterns for responsive CLI layouts and component composition.</description>
      <examples>
        <example title="Advanced Layout and Component Composition">
          <correct-example title="Responsive CLI layouts with Flexbox" conditions="Creating complex CLI layouts" expected-result="Well-structured, responsive CLI interfaces" correctness-criteria="Uses Flexbox patterns, responsive design, proper spacing, component composition">import React, { useState, useEffect } from 'react';
import { Box, Text, Newline, Spacer, useApp, Static } from 'ink';

// Layout component types
interface LayoutProps {
  children: React.ReactNode;
  padding?: number;
  margin?: number;
  border?: boolean;
}

interface GridProps {
  columns: number;
  gap?: number;
  children: React.ReactNode;
}

interface PanelProps {
  title: string;
  width?: number | string;
  height?: number;
  children: React.ReactNode;
  border?: boolean;
  focused?: boolean;
}

// Responsive grid layout component
const Grid: React.FC<GridProps> = ({ columns, gap = 1, children }) => {
  const childArray = React.Children.toArray(children);
  const rows: React.ReactNode[][] = [];
  
  for (let i = 0; i < childArray.length; i += columns) {
    rows.push(childArray.slice(i, i + columns));
  }

  return (
    <Box flexDirection="column">
      {rows.map((row, rowIndex) => (
        <Box key={rowIndex} marginBottom={gap}>
          {row.map((child, colIndex) => (
            <Box 
              key={colIndex} 
              flexGrow={1} 
              marginRight={colIndex < row.length - 1 ? gap : 0}
            >
              {child}
            </Box>
          ))}
        </Box>
      ))}
    </Box>
  );
};

// Panel component with borders and titles
const Panel: React.FC<PanelProps> = ({ 
  title, 
  width, 
  height, 
  children, 
  border = true,
  focused = false 
}) => {
  const borderColor = focused ? 'cyan' : 'gray';
  const titleColor = focused ? 'cyan' : 'white';

  if (!border) {
    return (
      <Box width={width} height={height} flexDirection="column">
        <Text bold color={titleColor}>{title}</Text>
        <Box flexDirection="column" flexGrow={1}>
          {children}
        </Box>
      </Box>
    );
  }

  return (
    <Box width={width} height={height} flexDirection="column" borderStyle="round" borderColor={borderColor}>
      <Box paddingX={1}>
        <Text bold color={titleColor}>{title}</Text>
      </Box>
      <Box flexDirection="column" flexGrow={1} paddingX={1} paddingBottom={1}>
        {children}
      </Box>
    </Box>
  );
};

// Sidebar layout component
const SidebarLayout: React.FC<{
  sidebar: React.ReactNode;
  main: React.ReactNode;
  sidebarWidth?: number;
  sidebarPosition?: 'left' | 'right';
}> = ({ sidebar, main, sidebarWidth = 20, sidebarPosition = 'left' }) => {
  return (
    <Box height="100%">
      {sidebarPosition === 'left' && (
        <Box width={sidebarWidth} flexShrink={0}>
          {sidebar}
        </Box>
      )}
      <Box flexGrow={1} marginLeft={sidebarPosition === 'left' ? 1 : 0} marginRight={sidebarPosition === 'right' ? 1 : 0}>
        {main}
      </Box>
      {sidebarPosition === 'right' && (
        <Box width={sidebarWidth} flexShrink={0}>
          {sidebar}
        </Box>
      )}
    </Box>
  );
};

// Status bar component
const StatusBar: React.FC<{
  left?: React.ReactNode;
  center?: React.ReactNode;
  right?: React.ReactNode;
}> = ({ left, center, right }) => {
  return (
    <Box backgroundColor="blue" paddingX={1}>
      <Box flexGrow={1}>
        {left}
      </Box>
      <Box>
        {center}
      </Box>
      <Box flexGrow={1} justifyContent="flex-end">
        {right}
      </Box>
    </Box>
  );
};

// Card component for content grouping
const Card: React.FC<{
  title?: string;
  children: React.ReactNode;
  padding?: number;
  margin?: number;
  highlighted?: boolean;
}> = ({ title, children, padding = 1, margin = 0, highlighted = false }) => {
  return (
    <Box 
      flexDirection="column" 
      borderStyle="single" 
      borderColor={highlighted ? 'yellow' : 'gray'}
      margin={margin}
      padding={padding}
    >
      {title && (
        <Box marginBottom={1}>
          <Text bold color={highlighted ? 'yellow' : 'white'}>{title}</Text>
        </Box>
      )}
      {children}
    </Box>
  );
};

// Dashboard layout example
const DashboardLayout: React.FC = () => {
  const [selectedPanel, setSelectedPanel] = useState(0);
  const [stats, setStats] = useState({
    cpu: 45,
    memory: 72,
    disk: 34,
    network: 12
  });

  // Simulate real-time updates
  useEffect(() => {
    const interval = setInterval(() => {
      setStats(prev => ({
        cpu: Math.max(0, Math.min(100, prev.cpu + (Math.random() - 0.5) * 10)),
        memory: Math.max(0, Math.min(100, prev.memory + (Math.random() - 0.5) * 5)),
        disk: Math.max(0, Math.min(100, prev.disk + (Math.random() - 0.5) * 2)),
        network: Math.max(0, Math.min(100, prev.network + (Math.random() - 0.5) * 15))
      }));
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  const StatCard: React.FC<{ label: string; value: number; unit: string }> = ({ label, value, unit }) => (
    <Card highlighted={value > 80}>
      <Text bold>{label}</Text>
      <Text color={value > 80 ? 'red' : value > 60 ? 'yellow' : 'green'}>
        {value.toFixed(1)}{unit}
      </Text>
    </Card>
  );

  const sidebar = (
    <Panel title="Navigation" focused={selectedPanel === 0}>
      <Box flexDirection="column">
        <Text color="cyan">‚Ä¢ Dashboard</Text>
        <Text>‚Ä¢ Processes</Text>
        <Text>‚Ä¢ Network</Text>
        <Text>‚Ä¢ Logs</Text>
      </Box>
    </Panel>
  );

  const main = (
    <Box flexDirection="column" height="100%">
      {/* Header */}
      <Panel title="System Monitor" focused={selectedPanel === 1}>
        <Grid columns={4} gap={1}>
          <StatCard label="CPU" value={stats.cpu} unit="%" />
          <StatCard label="Memory" value={stats.memory} unit="%" />
          <StatCard label="Disk" value={stats.disk} unit="%" />
          <StatCard label="Network" value={stats.network} unit="MB/s" />
        </Grid>
      </Panel>

      <Newline />

      {/* Content area */}
      <Box flexGrow={1}>
        <Box width="50%" marginRight={1}>
          <Panel title="Process List" focused={selectedPanel === 2}>
            <Box flexDirection="column">
              <Box>
                <Text bold color="blue">PID    Name           CPU%   Memory</Text>
              </Box>
              <Text>1234   node           12.3   256MB</Text>
              <Text>5678   chrome         8.7    512MB</Text>
              <Text>9012   code           15.2   384MB</Text>
              <Text>3456   terminal       2.1    64MB</Text>
            </Box>
          </Panel>
        </Box>

        <Box width="50%">
          <Panel title="System Logs" focused={selectedPanel === 3}>
            <Static items={[
              '[INFO] System started successfully',
              '[WARN] High memory usage detected',
              '[INFO] Network connection established',
              '[ERROR] Failed to connect to database',
              '[INFO] Database connection restored'
            ]}>
              {(item, index) => (
                <Box key={index}>
                  <Text color={
                    item.includes('[ERROR]') ? 'red' :
                    item.includes('[WARN]') ? 'yellow' : 'white'
                  }>
                    {item}
                  </Text>
                </Box>
              )}
            </Static>
          </Panel>
        </Box>
      </Box>

      {/* Status bar */}
      <StatusBar
        left={<Text>System Monitor v1.0</Text>}
        center={<Text>{new Date().toLocaleTimeString()}</Text>}
        right={<Text>Connected: ‚úì</Text>}
      />
    </Box>
  );

  return (
    <Box height="100%" flexDirection="column">
      <SidebarLayout
        sidebar={sidebar}
        main={main}
        sidebarWidth={20}
        sidebarPosition="left"
      />
    </Box>
  );
};

// Responsive table component
const Table: React.FC<{
  headers: string[];
  rows: string[][];
  maxWidth?: number;
}> = ({ headers, rows, maxWidth }) => {
  const columnWidths = headers.map((header, index) => {
    const maxContentWidth = Math.max(
      header.length,
      ...rows.map(row => (row[index] || '').length)
    );
    return Math.min(maxContentWidth + 2, maxWidth ? Math.floor(maxWidth / headers.length) : 20);
  });

  const truncateText = (text: string, width: number) => {
    return text.length > width - 2 ? text.slice(0, width - 5) + '...' : text;
  };

  return (
    <Box flexDirection="column">
      {/* Headers */}
      <Box>
        {headers.map((header, index) => (
          <Box key={index} width={columnWidths[index]} marginRight={1}>
            <Text bold color="blue">{truncateText(header, columnWidths[index])}</Text>
          </Box>
        ))}
      </Box>

      {/* Separator */}
      <Box>
        {columnWidths.map((width, index) => (
          <Box key={index} width={width} marginRight={1}>
            <Text color="gray">{'‚îÄ'.repeat(width - 1)}</Text>
          </Box>
        ))}
      </Box>

      {/* Rows */}
      {rows.map((row, rowIndex) => (
        <Box key={rowIndex}>
          {row.map((cell, cellIndex) => (
            <Box key={cellIndex} width={columnWidths[cellIndex]} marginRight={1}>
              <Text>{truncateText(cell || '', columnWidths[cellIndex])}</Text>
            </Box>
          ))}
        </Box>
      ))}
    </Box>
  );
};

export { Grid, Panel, SidebarLayout, StatusBar, Card, DashboardLayout, Table };</correct-example>
          <incorrect-example title="Poor layout without proper Flexbox usage" conditions="Creating complex CLI layouts" expected-result="Well-structured, responsive CLI interfaces" incorrectness-criteria="No Flexbox patterns, hardcoded dimensions, poor spacing, no component composition">const React = require('react');
const { Box, Text } = require('ink');

// Bad: No proper layout structure
const BadLayout = () => {
  return (
    <Box>
      {/* Bad: No Flexbox usage */}
      <Text>Left side content</Text>
      <Text>Right side content</Text>
    </Box>
  );
};

// Bad: Hardcoded dimensions
const BadPanel = () => {
  return (
    <Box width={50} height={20}>
      {/* Bad: Fixed dimensions, no responsiveness */}
      <Text>Fixed size panel</Text>
    </Box>
  );
};

// Bad: No component composition
const BadDashboard = () => {
  return (
    <Box>
      <Text>Title</Text>
      <Text>Some content</Text>
      <Text>More content</Text>
      <Text>Footer</Text>
      {/* Bad: No structure, no separation of concerns */}
    </Box>
  );
};

// Bad: No spacing or alignment
const BadTable = () => {
  return (
    <Box>
      <Text>Header1Header2Header3</Text>
      <Text>Data1Data2Data3</Text>
      {/* Bad: No column alignment, no spacing */}
    </Box>
  );
};</incorrect-example>
        </example>
      </examples>
    </non-negotiable>

    <requirement priority="high">
      <description>Implement comprehensive testing strategies for CLI applications using specialized testing tools and patterns for component testing, integration testing, and user interaction testing.</description>
      <examples>
        <example title="CLI Application Testing Patterns">
          <correct-example title="Comprehensive testing for Ink applications" conditions="Testing CLI applications thoroughly" expected-result="Well-tested CLI applications with good coverage" correctness-criteria="Uses proper testing tools, tests user interactions, component testing, integration testing">// __tests__/TaskManager.test.tsx
import React from 'react';
import { render, RenderResult } from 'ink-testing-library';
import { TaskManagerApp } from '../src/TaskManager';

// Mock external dependencies
jest.mock('commander', () => ({
  Command: jest.fn().mockImplementation(() => ({
    name: jest.fn().mockReturnThis(),
    description: jest.fn().mockReturnThis(),
    version: jest.fn().mockReturnThis(),
    option: jest.fn().mockReturnThis(),
    action: jest.fn().mockReturnThis(),
    parse: jest.fn()
  }))
}));

describe('TaskManagerApp', () => {
  let renderResult: RenderResult;

  beforeEach(() => {
    renderResult = render(<TaskManagerApp name="Test Manager" />);
  });

  afterEach(() => {
    renderResult.unmount();
  });

  describe('Component Rendering', () => {
    it('should render application title', () => {
      expect(renderResult.lastFrame()).toContain('Test Manager');
    });

    it('should display initial tasks', () => {
      expect(renderResult.lastFrame()).toContain('Setup project');
      expect(renderResult.lastFrame()).toContain('Install dependencies');
    });

    it('should show keyboard shortcuts', () => {
      expect(renderResult.lastFrame()).toContain('‚Üë/‚Üì Navigate');
      expect(renderResult.lastFrame()).toContain('Enter Run');
    });
  });

  describe('User Interactions', () => {
    it('should navigate tasks with arrow keys', async () => {
      // Initial state should have first task selected
      expect(renderResult.lastFrame()).toContain('‚ñ∂ ');
      
      // Press down arrow to move to next task
      renderResult.stdin.write('\x1B[B'); // Down arrow
      await renderResult.waitUntilExit();
      
      // Verify selection moved
      const frame = renderResult.lastFrame();
      const lines = frame.split('\n');
      const selectedLine = lines.find(line => line.includes('‚ñ∂'));
      expect(selectedLine).toContain('Install dependencies');
    });

    it('should run task when Enter is pressed', async () => {
      // Press Enter to run selected task
      renderResult.stdin.write('\r');
      
      // Wait for task to start running
      await new Promise(resolve => setTimeout(resolve, 100));
      
      expect(renderResult.lastFrame()).toContain('Task running');
    });

    it('should quit application with q key', async () => {
      renderResult.stdin.write('q');
      await renderResult.waitUntilExit();
      
      expect(renderResult.isExited).toBe(true);
    });

    it('should show help when h key is pressed', async () => {
      renderResult.stdin.write('h');
      await new Promise(resolve => setTimeout(resolve, 50));
      
      expect(renderResult.lastFrame()).toContain('Help - Keyboard Shortcuts');
      expect(renderResult.lastFrame()).toContain('‚Üë/‚Üì - Navigate tasks');
    });
  });

  describe('State Management', () => {
    it('should add new task when a key is pressed', async () => {
      const initialFrame = renderResult.lastFrame();
      const initialTaskCount = (initialFrame.match(/New Task/g) || []).length;
      
      renderResult.stdin.write('a');
      await new Promise(resolve => setTimeout(resolve, 50));
      
      const newFrame = renderResult.lastFrame();
      const newTaskCount = (newFrame.match(/New Task/g) || []).length;
      
      expect(newTaskCount).toBe(initialTaskCount + 1);
    });

    it('should update task status properly', async () => {
      // This would require mocking the task runner
      // In a real test, you'd mock the async operations
      jest.spyOn(Date, 'now')
        .mockReturnValueOnce(1000)
        .mockReturnValueOnce(2000);
      
      renderResult.stdin.write('\r'); // Run task
      
      // Verify task state changes through multiple frames
      await new Promise(resolve => setTimeout(resolve, 100));
      expect(renderResult.lastFrame()).toContain('üîÑ');
    });
  });
});

// __tests__/components/CommandInput.test.tsx
import React from 'react';
import { render } from 'ink-testing-library';
import { CommandInput } from '../src/components/CommandInput';

describe('CommandInput', () => {
  const mockOnCommand = jest.fn();
  const mockOnCancel = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should handle text input', async () => {
    const { stdin, lastFrame } = render(
      <CommandInput onCommand={mockOnCommand} onCancel={mockOnCancel} />
    );

    stdin.write('test command');
    await new Promise(resolve => setTimeout(resolve, 50));

    expect(lastFrame()).toContain('test command');
  });

  it('should execute command on Enter', async () => {
    const { stdin } = render(
      <CommandInput onCommand={mockOnCommand} onCancel={mockOnCancel} />
    );

    stdin.write('test command');
    stdin.write('\r'); // Enter key

    expect(mockOnCommand).toHaveBeenCalledWith('test command');
  });

  it('should cancel on Escape', async () => {
    const { stdin } = render(
      <CommandInput onCommand={mockOnCommand} onCancel={mockOnCancel} />
    );

    stdin.write('\x1B'); // Escape key

    expect(mockOnCancel).toHaveBeenCalled();
  });

  it('should handle backspace correctly', async () => {
    const { stdin, lastFrame } = render(
      <CommandInput onCommand={mockOnCommand} onCancel={mockOnCancel} />
    );

    stdin.write('hello');
    stdin.write('\x7F'); // Backspace
    await new Promise(resolve => setTimeout(resolve, 50));

    expect(lastFrame()).toContain('hell');
    expect(lastFrame()).not.toContain('hello');
  });

  it('should navigate command history', async () => {
    const { stdin, lastFrame, rerender } = render(
      <CommandInput onCommand={mockOnCommand} onCancel={mockOnCancel} />
    );

    // Add command to history
    stdin.write('first command');
    stdin.write('\r');

    // Start new command
    rerender(<CommandInput onCommand={mockOnCommand} onCancel={mockOnCancel} />);

    // Navigate to previous command
    stdin.write('\x1B[A'); // Up arrow
    await new Promise(resolve => setTimeout(resolve, 50));

    expect(lastFrame()).toContain('first command');
  });
});

// __tests__/integration/cli-workflow.test.ts
import { spawn, ChildProcess } from 'child_process';
import { promises as fs } from 'fs';
import path from 'path';

describe('CLI Workflow Integration', () => {
  let cliProcess: ChildProcess;
  const testOutput: string[] = [];

  beforeEach(() => {
    testOutput.length = 0;
  });

  afterEach(async () => {
    if (cliProcess && !cliProcess.killed) {
      cliProcess.kill('SIGTERM');
    }
  });

  const spawnCLI = (args: string[] = []) => {
    return new Promise<void>((resolve, reject) => {
      cliProcess = spawn('node', ['dist/cli.js', ...args], {
        stdio: ['pipe', 'pipe', 'pipe']
      });

      cliProcess.stdout?.on('data', (data) => {
        testOutput.push(data.toString());
      });

      cliProcess.stderr?.on('data', (data) => {
        testOutput.push(`ERROR: ${data.toString()}`);
      });

      cliProcess.on('spawn', resolve);
      cliProcess.on('error', reject);
    });
  };

  it('should start successfully with default options', async () => {
    await spawnCLI();
    
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const output = testOutput.join('');
    expect(output).toContain('Task Manager');
    expect(output).not.toContain('ERROR:');
  });

  it('should handle command line arguments', async () => {
    await spawnCLI(['--name', 'Custom App', '--verbose']);
    
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const output = testOutput.join('');
    expect(output).toContain('Custom App');
  });

  it('should handle invalid config file gracefully', async () => {
    await spawnCLI(['--config', '/nonexistent/config.json']);
    
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const output = testOutput.join('');
    expect(output).toContain('Config file not found');
  });

  it('should exit cleanly when quit command is sent', async () => {
    await spawnCLI();
    
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Send quit command
    cliProcess.stdin?.write('q');
    
    const exitPromise = new Promise((resolve) => {
      cliProcess.on('exit', resolve);
    });

    await exitPromise;
    expect(cliProcess.exitCode).toBe(0);
  });
});

// __tests__/accessibility/accessibility.test.tsx
import React from 'react';
import { render } from 'ink-testing-library';
import { AccessibleForm } from '../src/components/AccessibleForm';

describe('Accessibility Features', () => {
  const mockOnSubmit = jest.fn();
  const mockOnCancel = jest.fn();

  const testFields = [
    { name: 'name', label: 'Name', type: 'text' as const, required: true },
    { name: 'email', label: 'Email', type: 'text' as const, required: true },
    { name: 'notifications', label: 'Enable Notifications', type: 'checkbox' as const }
  ];

  it('should provide clear field labels', () => {
    const { lastFrame } = render(
      <AccessibleForm 
        fields={testFields}
        onSubmit={mockOnSubmit}
        onCancel={mockOnCancel}
      />
    );

    expect(lastFrame()).toContain('Name*:');
    expect(lastFrame()).toContain('Email*:');
    expect(lastFrame()).toContain('Enable Notifications:');
  });

  it('should indicate required fields', () => {
    const { lastFrame } = render(
      <AccessibleForm 
        fields={testFields}
        onSubmit={mockOnSubmit}
        onCancel={mockOnCancel}
      />
    );

    expect(lastFrame()).toContain('*'); // Required field indicator
  });

  it('should show keyboard navigation instructions', () => {
    const { lastFrame } = render(
      <AccessibleForm 
        fields={testFields}
        onSubmit={mockOnSubmit}
        onCancel={mockOnCancel}
      />
    );

    expect(lastFrame()).toContain('Tab/‚Üë‚Üì: Navigate');
    expect(lastFrame()).toContain('Enter: Next/Submit');
    expect(lastFrame()).toContain('Esc: Cancel');
  });

  it('should highlight current field', () => {
    const { lastFrame } = render(
      <AccessibleForm 
        fields={testFields}
        onSubmit={mockOnSubmit}
        onCancel={mockOnCancel}
      />
    );

    expect(lastFrame()).toContain('‚ñ∂'); // Current field indicator
  });
});

// Performance testing utilities
// __tests__/performance/performance.test.ts
import { performance } from 'perf_hooks';
import { render } from 'ink-testing-library';
import { TaskManagerApp } from '../src/TaskManager';

describe('Performance Tests', () => {
  it('should render within acceptable time limits', () => {
    const startTime = performance.now();
    
    const { unmount } = render(<TaskManagerApp />);
    
    const renderTime = performance.now() - startTime;
    
    expect(renderTime).toBeLessThan(100); // Should render in less than 100ms
    
    unmount();
  });

  it('should handle rapid input without lag', async () => {
    const { stdin } = render(<TaskManagerApp />);
    
    const startTime = performance.now();
    
    // Simulate rapid key presses
    for (let i = 0; i < 100; i++) {
      stdin.write('\x1B[B'); // Down arrow
    }
    
    await new Promise(resolve => setTimeout(resolve, 100));
    
    const processingTime = performance.now() - startTime;
    
    expect(processingTime).toBeLessThan(200); // Should handle 100 inputs in less than 200ms
  });

  it('should not have memory leaks with many re-renders', async () => {
    const initialMemory = process.memoryUsage().heapUsed;
    
    for (let i = 0; i < 100; i++) {
      const { unmount } = render(<TaskManagerApp />);
      unmount();
    }
    
    // Force garbage collection if available
    if (global.gc) {
      global.gc();
    }
    
    await new Promise(resolve => setTimeout(resolve, 100));
    
    const finalMemory = process.memoryUsage().heapUsed;
    const memoryIncrease = finalMemory - initialMemory;
    
    // Memory increase should be minimal (less than 10MB)
    expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);
  });
});

// Test configuration
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/__tests__'],
  testMatch: [
    '**/__tests__/**/*.+(ts|tsx|js)',
    '**/*.(test|spec).+(ts|tsx|js)'
  ],
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest'
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/index.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  setupFilesAfterEnv: ['<rootDir>/__tests__/setup.ts'],
  testTimeout: 10000
};

// Test setup
// __tests__/setup.ts
import 'jest-extended';

// Mock process.exit to prevent tests from actually exiting
const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => {
  throw new Error('process.exit called');
});

// Mock console methods to reduce noise in tests
global.console = {
  ...console,
  log: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  info: jest.fn()
};

beforeEach(() => {
  mockExit.mockClear();
});

afterAll(() => {
  mockExit.mockRestore();
});</correct-example>
          <incorrect-example title="Poor testing practices for CLI applications" conditions="Testing CLI applications thoroughly" expected-result="Well-tested CLI applications with good coverage" incorrectness-criteria="No proper testing setup, manual testing only, no user interaction testing, poor test coverage">// Bad: No proper testing setup
const { spawn } = require('child_process');

// Bad: Manual testing only
describe('TaskManager', () => {
  it('should work', () => {
    // Bad: No actual testing
    expect(true).toBe(true);
  });
});

// Bad: No component testing
// Just manual process spawning without proper assertions

// Bad: No user interaction testing
function testCLI() {
  const child = spawn('node', ['cli.js']);
  
  // Bad: No proper waiting or assertions
  child.stdout.on('data', (data) => {
    console.log(data.toString());
  });
  
  // Bad: No cleanup
  // Bad: No error handling
}

// Bad: No accessibility testing
// Bad: No performance testing
// Bad: No integration testing</incorrect-example>
        </example>
      </examples>
    </requirement>

    <requirement priority="high">
      <description>Implement proper state management patterns with React hooks, context, and external state libraries optimized for CLI applications with real-time updates and complex interactions.</description>
      <examples>
        <example title="Advanced State Management for CLI Applications">
          <correct-example title="Comprehensive state management with hooks and context" conditions="Managing complex state in CLI applications" expected-result="Well-organized state management with proper updates" correctness-criteria="Uses React hooks, context API, proper state patterns, handles async operations">import React, { createContext, useContext, useReducer, useEffect, useMemo } from 'react';
import { EventEmitter } from 'events';

// State types
interface AppState {
  currentView: 'main' | 'settings' | 'help' | 'logs';
  selectedItem: number;
  isLoading: boolean;
  error: string | null;
  config: AppConfig;
  tasks: Task[];
  processes: Process[];
  logs: LogEntry[];
}

interface AppConfig {
  theme: 'dark' | 'light';
  refreshInterval: number;
  maxLogEntries: number;
  autoSave: boolean;
}

interface Task {
  id: string;
  name: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  progress: number;
  startTime?: Date;
  endTime?: Date;
  output: string[];
}

interface Process {
  pid: number;
  name: string;
  cpu: number;
  memory: number;
  status: 'running' | 'sleeping' | 'stopped';
}

interface LogEntry {
  id: string;
  timestamp: Date;
  level: 'info' | 'warn' | 'error' | 'debug';
  message: string;
  source: string;
}

// Action types
type AppAction =
  | { type: 'SET_VIEW'; payload: AppState['currentView'] }
  | { type: 'SET_SELECTED_ITEM'; payload: number }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'UPDATE_CONFIG'; payload: Partial<AppConfig> }
  | { type: 'ADD_TASK'; payload: Omit<Task, 'id'> }
  | { type: 'UPDATE_TASK'; payload: { id: string; updates: Partial<Task> } }
  | { type: 'REMOVE_TASK'; payload: string }
  | { type: 'SET_PROCESSES'; payload: Process[] }
  | { type: 'ADD_LOG'; payload: Omit<LogEntry, 'id'> }
  | { type: 'CLEAR_LOGS' }
  | { type: 'RESET_STATE' };

// Initial state
const initialState: AppState = {
  currentView: 'main',
  selectedItem: 0,
  isLoading: false,
  error: null,
  config: {
    theme: 'dark',
    refreshInterval: 1000,
    maxLogEntries: 1000,
    autoSave: true
  },
  tasks: [],
  processes: [],
  logs: []
};

// Reducer
const appReducer = (state: AppState, action: AppAction): AppState => {
  switch (action.type) {
    case 'SET_VIEW':
      return { ...state, currentView: action.payload, selectedItem: 0 };
    
    case 'SET_SELECTED_ITEM':
      return { ...state, selectedItem: action.payload };
    
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };
    
    case 'SET_ERROR':
      return { ...state, error: action.payload };
    
    case 'UPDATE_CONFIG':
      return { 
        ...state, 
        config: { ...state.config, ...action.payload }
      };
    
    case 'ADD_TASK':
      const newTask: Task = {
        ...action.payload,
        id: `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
      };
      return { 
        ...state, 
        tasks: [...state.tasks, newTask]
      };
    
    case 'UPDATE_TASK':
      return {
        ...state,
        tasks: state.tasks.map(task =>
          task.id === action.payload.id
            ? { ...task, ...action.payload.updates }
            : task
        )
      };
    
    case 'REMOVE_TASK':
      return {
        ...state,
        tasks: state.tasks.filter(task => task.id !== action.payload)
      };
    
    case 'SET_PROCESSES':
      return { ...state, processes: action.payload };
    
    case 'ADD_LOG':
      const newLog: LogEntry = {
        ...action.payload,
        id: `log-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
      };
      
      const updatedLogs = [...state.logs, newLog];
      
      // Trim logs if exceeding max entries
      const trimmedLogs = updatedLogs.length > state.config.maxLogEntries
        ? updatedLogs.slice(-state.config.maxLogEntries)
        : updatedLogs;
      
      return { ...state, logs: trimmedLogs };
    
    case 'CLEAR_LOGS':
      return { ...state, logs: [] };
    
    case 'RESET_STATE':
      return initialState;
    
    default:
      return state;
  }
};

// Context
const AppContext = createContext<{
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
  actions: AppActions;
} | null>(null);

// Action creators
interface AppActions {
  setView: (view: AppState['currentView']) => void;
  setSelectedItem: (index: number) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  updateConfig: (config: Partial<AppConfig>) => void;
  addTask: (task: Omit<Task, 'id'>) => void;
  updateTask: (id: string, updates: Partial<Task>) => void;
  removeTask: (id: string) => void;
  setProcesses: (processes: Process[]) => void;
  addLog: (log: Omit<LogEntry, 'id'>) => void;
  clearLogs: () => void;
  resetState: () => void;
}

// Provider component
export const AppProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(appReducer, initialState);

  const actions: AppActions = useMemo(() => ({
    setView: (view) => dispatch({ type: 'SET_VIEW', payload: view }),
    setSelectedItem: (index) => dispatch({ type: 'SET_SELECTED_ITEM', payload: index }),
    setLoading: (loading) => dispatch({ type: 'SET_LOADING', payload: loading }),
    setError: (error) => dispatch({ type: 'SET_ERROR', payload: error }),
    updateConfig: (config) => dispatch({ type: 'UPDATE_CONFIG', payload: config }),
    addTask: (task) => dispatch({ type: 'ADD_TASK', payload: task }),
    updateTask: (id, updates) => dispatch({ type: 'UPDATE_TASK', payload: { id, updates } }),
    removeTask: (id) => dispatch({ type: 'REMOVE_TASK', payload: id }),
    setProcesses: (processes) => dispatch({ type: 'SET_PROCESSES', payload: processes }),
    addLog: (log) => dispatch({ type: 'ADD_LOG', payload: log }),
    clearLogs: () => dispatch({ type: 'CLEAR_LOGS' }),
    resetState: () => dispatch({ type: 'RESET_STATE' })
  }), []);

  return (
    <AppContext.Provider value={{ state, dispatch, actions }}>
      {children}
    </AppContext.Provider>
  );
};

// Hook to use app context
export const useAppContext = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within an AppProvider');
  }
  return context;
};

// Custom hooks for specific state slices
export const useCurrentView = () => {
  const { state, actions } = useAppContext();
  return {
    currentView: state.currentView,
    setView: actions.setView
  };
};

export const useSelection = () => {
  const { state, actions } = useAppContext();
  return {
    selectedItem: state.selectedItem,
    setSelectedItem: actions.setSelectedItem
  };
};

export const useTasks = () => {
  const { state, actions } = useAppContext();
  return {
    tasks: state.tasks,
    addTask: actions.addTask,
    updateTask: actions.updateTask,
    removeTask: actions.removeTask
  };
};

export const useProcesses = () => {
  const { state, actions } = useAppContext();
  return {
    processes: state.processes,
    setProcesses: actions.setProcesses
  };
};

export const useLogs = () => {
  const { state, actions } = useAppContext();
  return {
    logs: state.logs,
    addLog: actions.addLog,
    clearLogs: actions.clearLogs
  };
};

export const useConfig = () => {
  const { state, actions } = useAppContext();
  return {
    config: state.config,
    updateConfig: actions.updateConfig
  };
};

// Real-time data hooks
export const useRealTimeProcesses = () => {
  const { setProcesses } = useProcesses();
  const { addLog } = useLogs();
  const { config } = useConfig();

  useEffect(() => {
    const fetchProcesses = async () => {
      try {
        // In a real implementation, this would fetch actual process data
        const mockProcesses: Process[] = [
          { pid: 1234, name: 'node', cpu: Math.random() * 100, memory: 256, status: 'running' },
          { pid: 5678, name: 'chrome', cpu: Math.random() * 100, memory: 512, status: 'running' },
          { pid: 9012, name: 'code', cpu: Math.random() * 100, memory: 384, status: 'running' }
        ];
        
        setProcesses(mockProcesses);
      } catch (error) {
        addLog({
          timestamp: new Date(),
          level: 'error',
          message: `Failed to fetch processes: ${error.message}`,
          source: 'process-monitor'
        });
      }
    };

    fetchProcesses();
    const interval = setInterval(fetchProcesses, config.refreshInterval);

    return () => clearInterval(interval);
  }, [config.refreshInterval, setProcesses, addLog]);
};

// Task management with async operations
export const useTaskRunner = () => {
  const { updateTask, addLog } = useAppContext().actions;

  const runTask = async (taskId: string) => {
    try {
      updateTask(taskId, { 
        status: 'running', 
        startTime: new Date(),
        progress: 0 
      });

      addLog({
        timestamp: new Date(),
        level: 'info',
        message: `Started task ${taskId}`,
        source: 'task-runner'
      });

      // Simulate task execution with progress updates
      for (let progress = 0; progress <= 100; progress += 10) {
        await new Promise(resolve => setTimeout(resolve, 100));
        
        updateTask(taskId, { progress });
        
        if (progress % 25 === 0) {
          addLog({
            timestamp: new Date(),
            level: 'info',
            message: `Task ${taskId} progress: ${progress}%`,
            source: 'task-runner'
          });
        }
      }

      updateTask(taskId, { 
        status: 'completed', 
        endTime: new Date(),
        progress: 100 
      });

      addLog({
        timestamp: new Date(),
        level: 'info',
        message: `Completed task ${taskId}`,
        source: 'task-runner'
      });

    } catch (error) {
      updateTask(taskId, { 
        status: 'failed', 
        endTime: new Date() 
      });

      addLog({
        timestamp: new Date(),
        level: 'error',
        message: `Task ${taskId} failed: ${error.message}`,
        source: 'task-runner'
      });
    }
  };

  return { runTask };
};

// Event emitter for global events
class AppEventEmitter extends EventEmitter {}
export const appEvents = new AppEventEmitter();

// Hook for listening to global events
export const useAppEvents = () => {
  const { actions } = useAppContext();

  useEffect(() => {
    const handleGlobalError = (error: Error) => {
      actions.setError(error.message);
      actions.addLog({
        timestamp: new Date(),
        level: 'error',
        message: `Global error: ${error.message}`,
        source: 'app'
      });
    };

    const handleKeyboardShortcut = (shortcut: string) => {
      actions.addLog({
        timestamp: new Date(),
        level: 'debug',
        message: `Keyboard shortcut: ${shortcut}`,
        source: 'input'
      });
    };

    appEvents.on('global-error', handleGlobalError);
    appEvents.on('keyboard-shortcut', handleKeyboardShortcut);

    return () => {
      appEvents.off('global-error', handleGlobalError);
      appEvents.off('keyboard-shortcut', handleKeyboardShortcut);
    };
  }, [actions]);
};

// Persistence hook
export const usePersistence = () => {
  const { state, actions } = useAppContext();
  
  // Save state to file system
  useEffect(() => {
    if (state.config.autoSave) {
      const saveData = {
        config: state.config,
        tasks: state.tasks.filter(task => task.status !== 'running')
      };
      
      // In a real implementation, save to file
      localStorage.setItem('app-state', JSON.stringify(saveData));
    }
  }, [state.config, state.tasks]);

  // Load state on mount
  useEffect(() => {
    try {
      const savedData = localStorage.getItem('app-state');
      if (savedData) {
        const parsed = JSON.parse(savedData);
        if (parsed.config) {
          actions.updateConfig(parsed.config);
        }
        if (parsed.tasks) {
          parsed.tasks.forEach((task: Task) => {
            actions.addTask(task);
          });
        }
      }
    } catch (error) {
      actions.addLog({
        timestamp: new Date(),
        level: 'warn',
        message: `Failed to load saved state: ${error.message}`,
        source: 'persistence'
      });
    }
  }, [actions]);
};</correct-example>
          <incorrect-example title="Poor state management without proper patterns" conditions="Managing complex state in CLI applications" expected-result="Well-organized state management with proper updates" incorrectness-criteria="No state management pattern, global variables, no context, poor async handling">// Bad: Global variables instead of proper state management
let currentView = 'main';
let selectedItem = 0;
let tasks = [];
let isLoading = false;

// Bad: No context or proper state containers
const App = () => {
  // Bad: Direct manipulation of global state
  const handleViewChange = (view) => {
    currentView = view;
    // Bad: No re-render mechanism
  };

  return (
    <Box>
      <Text>{currentView}</Text>
    </Box>
  );
};

// Bad: No proper async state handling
const runTask = (taskId) => {
  // Bad: Direct mutation
  tasks.find(t => t.id === taskId).status = 'running';
  
  // Bad: No error handling, no progress tracking
  setTimeout(() => {
    tasks.find(t => t.id === taskId).status = 'completed';
  }, 1000);
};

// Bad: No event system or proper communication
// Bad: No persistence
// Bad: No proper hooks or abstraction</incorrect-example>
        </example>
      </examples>
    </requirement>
  </requirements>
</rule>
description:
globs:
alwaysApply: false
---
