---
description: "Best practices for developing applications with Vite."
globs: ["*.{js,ts,jsx,tsx}"]
alwaysApply: false
---
<rule>
  <meta>
    <title>Vite Best Practices</title>
    <description>This document outlines best practices for developing applications using Vite, a fast and opinionated build tool that aims to provide a better development experience.</description>
    <created-at utc-timestamp="1744326000">April 11, 2025, 11:00 AM AEST</created-at>
    <last-updated-at utc-timestamp="1744326000">April 11, 2025, 11:00 AM AEST</last-updated-at>
    <applies-to>
      <file-matcher glob="*">All files when working on a Vite project</file-matcher>
    </applies-to>
  </meta>
  <requirements>
    <requirement priority="high">
        <description>Adopt a modular structure based on features or components.</description>
        <examples>
            <example title="Directory Structure">
                <correct-example title="Modular directory structure" conditions="Organizing a new project" expected-result="A clean and scalable project structure" correctness-criteria="Files are grouped by feature or component."><![CDATA[
src/
├── components/
│   ├── Button/
│   │   ├── Button.tsx
│   │   ├── Button.module.css
│   │   └── Button.test.tsx
│   ├── Input/
│   │   └── ...
├── pages/
│   ├── Home.tsx
│   ├── About.tsx
│   └── ...
├── services/
│   ├── api.ts
│   └── ...
├── utils/
│   ├── helpers.ts
│   └── ...
├── App.tsx
├── main.tsx
└── vite-env.d.ts
]]></correct-example>
            </example>
        </examples>
    </requirement>
    <requirement priority="medium">
        <description>Use descriptive and consistent file naming conventions.</description>
        <examples>
            <example title="File Naming">
                <correct-example title="Consistent file names" conditions="Creating new files" expected-result="Readable and maintainable file structure" correctness-criteria="Follows a consistent naming scheme."><![CDATA[
// Component files: 
ComponentName.tsx or component-name.tsx

// Style files: 
ComponentName.module.css or component-name.module.css

// Test files: 
ComponentName.test.tsx or component-name.test.tsx
]]></correct-example>
            </example>
        </examples>
    </requirement>
    <requirement priority="high">
        <description>Favor small, reusable components and separate concerns.</description>
    </requirement>
    <requirement priority="medium">
        <description>Use dynamic imports (`import()`) for code splitting and lazy loading.</description>
    </requirement>
    <requirement priority="high">
        <description>Use environment variables for configuration.</description>
    </requirement>
    <requirement priority="high">
        <description>Implement a consistent API client for data fetching.</description>
    </requirement>
    <requirement priority="high">
        <description>Centralize state management using libraries like Redux, Zustand, or Vuex when appropriate.</description>
    </requirement>
    <requirement priority="critical">
        <description>Avoid common anti-patterns like deeply nested component trees without optimization, direct state mutation, and overusing global styles.</description>
    </requirement>
    <requirement priority="high">
        <description>Implement global error boundaries and local error handling.</description>
    </requirement>
    <requirement priority="high">
        <description>Optimize performance through code minification, asset optimization, and memory management.</description>
    </requirement>
    <requirement priority="critical">
        <description>Address common security vulnerabilities like XSS, CSRF, and injection attacks by sanitizing and validating all user input.</description>
    </requirement>
    <requirement priority="critical">
        <description>Use a secure authentication and authorization mechanism and protect sensitive data.</description>
    </requirement>
    <requirement priority="high">
        <description>Write unit, integration, and end-to-end tests for your application.</description>
    </requirement>
     <requirement priority="high">
        <description>Enable strict type-checking in TypeScript and use interfaces or types for props and state.</description>
        <examples>
            <example title="Typing Props and State">
            <correct-example title="Strongly typed component props" conditions="Defining a React component in TypeScript" expected-result="A component with clearly defined and type-checked props" correctness-criteria="Uses a TypeScript interface to define the props."><![CDATA[
interface ButtonProps {
  label: string;
  onClick: () => void;
}

const Button: React.FC<ButtonProps> = ({ label, onClick }) => {
  return <button onClick={onClick}>{label}</button>;
};
]]></correct-example>
            </example>
        </examples>
    </requirement>
  </requirements>
  <references>
    <reference as="dependency" href=".cursor/rules/rules.mdc" reason="Follows standard rule format">Base rule format definition</reference>
  </references>
</rule>