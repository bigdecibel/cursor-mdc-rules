---
description: Comprehensive Elixir and Phoenix project setup with modern file system layout, build tools, linters, umbrella applications, and OTP best practices following community standards
globs: "*.{ex,exs,eex,heex,leex}"
alwaysApply: false
---

<rule>
  <meta>
    <title>Elixir Core Project Rules</title>
    <description>Comprehensive Elixir and Phoenix project setup with modern file system layout, build tools, linters, umbrella applications, and OTP best practices following community standards</description>
    <created-at utc-timestamp="1744245120">January 27, 2025, 11:38 AM</created-at>
    <last-updated-at utc-timestamp="1744245120">January 27, 2025, 11:38 AM</last-updated-at>
    <applies-to>
      <file-matcher glob="*.{ex,exs,eex,heex,leex}">All Elixir source files and templates</file-matcher>
      <action-matcher action="elixir-project-setup">Triggered when setting up or maintaining Elixir/Phoenix projects</action-matcher>
    </applies-to>
  </meta>
  <requirements>
    <non-negotiable priority="critical">
      <description>Use proper Phoenix application file system layout following official Phoenix and Elixir community conventions for maintainable and scalable projects.</description>
      <examples>
        <example title="Phoenix Application Structure">
          <correct-example title="Proper Phoenix project structure" conditions="Setting up new Phoenix application" expected-result="Well-organized Phoenix project with clear boundaries" correctness-criteria="Uses official Phoenix conventions with proper separation of concerns"><![CDATA[my_phoenix_app/
├── lib/
│   ├── my_phoenix_app/
│   │   ├── application.ex
│   │   ├── repo.ex
│   │   ├── accounts/
│   │   │   ├── user.ex
│   │   │   ├── user_token.ex
│   │   │   └── accounts.ex
│   │   ├── blog/
│   │   │   ├── post.ex
│   │   │   ├── comment.ex
│   │   │   └── blog.ex
│   │   └── workers/
│   │       ├── email_worker.ex
│   │       └── report_worker.ex
│   └── my_phoenix_app_web/
│       ├── controllers/
│       │   ├── user_controller.ex
│       │   ├── post_controller.ex
│       │   └── page_controller.ex
│       ├── live/
│       │   ├── user_live/
│       │   │   ├── index.ex
│       │   │   ├── show.ex
│       │   │   └── form_component.ex
│       │   └── post_live/
│       ├── components/
│       │   ├── core_components.ex
│       │   ├── layouts.ex
│       │   └── ui/
│       │       ├── button.ex
│       │       └── card.ex
│       ├── templates/
│       │   └── layout/
│       │       ├── app.html.heex
│       │       └── root.html.heex
│       ├── views/
│       │   ├── user_view.ex
│       │   └── post_view.ex
│       ├── endpoint.ex
│       ├── router.ex
│       ├── telemetry.ex
│       └── gettext.ex
├── test/
│   ├── my_phoenix_app/
│   │   ├── accounts_test.exs
│   │   └── blog_test.exs
│   ├── my_phoenix_app_web/
│   │   ├── controllers/
│   │   │   ├── user_controller_test.exs
│   │   │   └── post_controller_test.exs
│   │   ├── live/
│   │   │   └── user_live_test.exs
│   │   └── views/
│   ├── support/
│   │   ├── channel_case.ex
│   │   ├── conn_case.ex
│   │   ├── data_case.ex
│   │   └── fixtures/
│   └── test_helper.exs
├── priv/
│   ├── repo/
│   │   ├── migrations/
│   │   │   └── 20231201000000_create_users.exs
│   │   └── seeds.exs
│   ├── static/
│   │   ├── assets/
│   │   ├── images/
│   │   └── favicon.ico
│   └── gettext/
├── config/
│   ├── config.exs
│   ├── dev.exs
│   ├── prod.exs
│   ├── runtime.exs
│   └── test.exs
├── assets/
│   ├── js/
│   │   ├── app.js
│   │   └── user_socket.js
│   ├── css/
│   │   └── app.css
│   ├── vendor/
│   └── package.json
├── deps/
├── _build/
├── .formatter.exs
├── .credo.exs
├── .gitignore
├── mix.exs
├── mix.lock
└── README.md]]></correct-example>
          <incorrect-example title="Poor Phoenix project structure" conditions="Setting up new Phoenix application" expected-result="Well-organized Phoenix project with clear boundaries" incorrectness-criteria="Violates Phoenix conventions, mixed concerns, poor organization"><![CDATA[my_app/
├── lib/
│   ├── controllers/
│   ├── models/
│   ├── views/
│   ├── services/
│   └── utils/
├── web/
│   ├── templates/
│   └── static/
├── test/
├── config/
└── mix.exs

# Problems:
# - Not following Phoenix conventions
# - Mixing web and business logic
# - No proper context boundaries
# - Poor separation of concerns
# - Missing essential directories]]></incorrect-example>
        </example>
      </examples>
    </non-negotiable>

    <non-negotiable priority="critical">
      <description>Use proper Umbrella application structure for large-scale Elixir projects with clear app boundaries and shared dependencies.</description>
      <examples>
        <example title="Umbrella Application Structure">
          <correct-example title="Proper Umbrella project structure" conditions="Setting up umbrella application" expected-result="Well-organized umbrella with clear app boundaries" correctness-criteria="Uses proper umbrella conventions with shared dependencies and clear boundaries"><![CDATA[my_umbrella/
├── apps/
│   ├── my_app_core/
│   │   ├── lib/
│   │   │   ├── my_app_core/
│   │   │   │   ├── application.ex
│   │   │   │   ├── accounts/
│   │   │   │   │   ├── user.ex
│   │   │   │   │   ├── user_token.ex
│   │   │   │   │   └── accounts.ex
│   │   │   │   ├── blog/
│   │   │   │   │   ├── post.ex
│   │   │   │   │   └── blog.ex
│   │   │   │   └── repo.ex
│   │   │   └── my_app_core.ex
│   │   ├── test/
│   │   ├── mix.exs
│   │   └── README.md
│   ├── my_app_web/
│   │   ├── lib/
│   │   │   ├── my_app_web/
│   │   │   │   ├── application.ex
│   │   │   │   ├── controllers/
│   │   │   │   ├── live/
│   │   │   │   ├── components/
│   │   │   │   ├── endpoint.ex
│   │   │   │   ├── router.ex
│   │   │   │   └── telemetry.ex
│   │   │   └── my_app_web.ex
│   │   ├── test/
│   │   ├── mix.exs
│   │   └── README.md
│   ├── my_app_workers/
│   │   ├── lib/
│   │   │   ├── my_app_workers/
│   │   │   │   ├── application.ex
│   │   │   │   ├── email_worker.ex
│   │   │   │   ├── report_worker.ex
│   │   │   │   └── scheduler.ex
│   │   │   └── my_app_workers.ex
│   │   ├── test/
│   │   ├── mix.exs
│   │   └── README.md
│   └── my_app_api/
│       ├── lib/
│       │   ├── my_app_api/
│       │   │   ├── application.ex
│       │   │   ├── router.ex
│       │   │   ├── controllers/
│       │   │   └── views/
│       │   └── my_app_api.ex
│       ├── test/
│       ├── mix.exs
│       └── README.md
├── config/
│   ├── config.exs
│   ├── dev.exs
│   ├── prod.exs
│   ├── runtime.exs
│   └── test.exs
├── deps/
├── _build/
├── .formatter.exs
├── .credo.exs
├── .gitignore
├── mix.exs
├── mix.lock
└── README.md

# mix.exs (umbrella root)
defmodule MyUmbrella.MixProject do
  use Mix.Project

  def project do
    [
      apps_path: "apps",
      version: "0.1.0",
      start_permanent: Mix.env() == :prod,
      deps: deps(),
      aliases: aliases(),
      releases: releases()
    ]
  end

  defp deps do
    [
      # Shared dependencies
      {:credo, "~> 1.7", only: [:dev, :test], runtime: false},
      {:dialyxir, "~> 1.3", only: [:dev], runtime: false},
      {:ex_doc, "~> 0.27", only: :dev, runtime: false}
    ]
  end

  defp aliases do
    [
      setup: ["deps.get", "ecto.setup"],
      "ecto.setup": ["ecto.create", "ecto.migrate", "run priv/repo/seeds.exs"],
      "ecto.reset": ["ecto.drop", "ecto.setup"],
      test: ["ecto.create --quiet", "ecto.migrate --quiet", "test"],
      "assets.deploy": [
        "cmd --cd apps/my_app_web/assets npm run deploy",
        "esbuild default --minify",
        "phx.digest"
      ]
    ]
  end

  defp releases do
    [
      my_app: [
        version: "0.1.0",
        applications: [
          my_app_core: :permanent,
          my_app_web: :permanent,
          my_app_workers: :permanent,
          my_app_api: :permanent
        ]
      ]
    ]
  end
end]]></correct-example>
          <incorrect-example title="Poor Umbrella structure" conditions="Setting up umbrella application" expected-result="Well-organized umbrella with clear app boundaries" incorrectness-criteria="Poor app boundaries, shared state, tight coupling"><![CDATA[my_umbrella/
├── apps/
│   ├── app1/
│   └── app2/
├── mix.exs
└── config/

# Problems:
# - No clear app purpose or boundaries
# - Missing proper configuration
# - No shared dependency management
# - Poor naming conventions
# - Missing essential umbrella structure]]></incorrect-example>
        </example>
      </examples>
    </non-negotiable>

    <requirement priority="critical">
      <description>Configure Mix build tool with proper dependencies, aliases, and environment-specific settings for efficient development and deployment.</description>
      <examples>
        <example title="Mix Configuration">
          <correct-example title="Proper Mix project setup" conditions="Configuring Mix for Elixir project" expected-result="Efficient build and development workflow" correctness-criteria="Uses proper dependencies, aliases, and environment configuration"><![CDATA[# mix.exs
defmodule MyPhoenixApp.MixProject do
  use Mix.Project

  def project do
    [
      app: :my_phoenix_app,
      version: "0.1.0",
      elixir: "~> 1.14",
      elixirc_paths: elixirc_paths(Mix.env()),
      start_permanent: Mix.env() == :prod,
      aliases: aliases(),
      deps: deps(),
      test_coverage: [tool: ExCoveralls],
      preferred_cli_env: [
        coveralls: :test,
        "coveralls.detail": :test,
        "coveralls.post": :test,
        "coveralls.html": :test
      ],
      dialyzer: [
        plt_file: {:no_warn, "priv/plts/dialyzer.plt"},
        plt_add_apps: [:mix]
      ],
      releases: releases()
    ]
  end

  def application do
    [
      mod: {MyPhoenixApp.Application, []},
      extra_applications: [:logger, :runtime_tools, :os_mon]
    ]
  end

  defp elixirc_paths(:test), do: ["lib", "test/support"]
  defp elixirc_paths(_), do: ["lib"]

  defp deps do
    [
      # Phoenix Framework
      {:phoenix, "~> 1.7.7"},
      {:phoenix_ecto, "~> 4.4"},
      {:ecto_sql, "~> 3.10"},
      {:postgrex, ">= 0.0.0"},
      {:phoenix_html, "~> 3.3"},
      {:phoenix_live_reload, "~> 1.2", only: :dev},
      {:phoenix_live_view, "~> 0.19.0"},
      {:floki, ">= 0.30.0", only: :test},
      {:phoenix_live_dashboard, "~> 0.8.0"},
      {:esbuild, "~> 0.7", runtime: Mix.env() == :dev},
      {:tailwind, "~> 0.2.0", runtime: Mix.env() == :dev},
      {:swoosh, "~> 1.3"},
      {:finch, "~> 0.13"},
      {:telemetry_metrics, "~> 0.6"},
      {:telemetry_poller, "~> 1.0"},
      {:gettext, "~> 0.20"},
      {:jason, "~> 1.2"},
      {:dns_cluster, "~> 0.1.1"},
      {:plug_cowboy, "~> 2.5"},

      # Authentication & Authorization
      {:bcrypt_elixir, "~> 3.0"},
      {:phx_gen_auth, "~> 0.7", only: :dev, runtime: false},

      # Background Jobs
      {:oban, "~> 2.15"},

      # Caching
      {:nebulex, "~> 2.4"},

      # HTTP Client
      {:req, "~> 0.4.0"},

      # JSON Web Tokens
      {:joken, "~> 2.5"},

      # Image Processing
      {:image, "~> 0.37"},

      # Development & Testing
      {:credo, "~> 1.7", only: [:dev, :test], runtime: false},
      {:dialyxir, "~> 1.3", only: [:dev], runtime: false},
      {:excoveralls, "~> 0.16", only: :test},
      {:ex_doc, "~> 0.27", only: :dev, runtime: false},
      {:sobelow, "~> 0.8", only: [:dev, :test], runtime: false},
      {:ex_machina, "~> 2.7.0", only: :test},
      {:mox, "~> 1.0", only: :test},

      # Deployment
      {:libcluster, "~> 3.3"}
    ]
  end

  defp aliases do
    [
      setup: ["deps.get", "ecto.setup", "assets.setup", "assets.build"],
      "ecto.setup": ["ecto.create", "ecto.migrate", "run priv/repo/seeds.exs"],
      "ecto.reset": ["ecto.drop", "ecto.setup"],
      test: ["ecto.create --quiet", "ecto.migrate --quiet", "test"],
      "assets.setup": ["tailwind.install --if-missing", "esbuild.install --if-missing"],
      "assets.build": ["tailwind default", "esbuild default"],
      "assets.deploy": ["tailwind default --minify", "esbuild default --minify", "phx.digest"],
      lint: ["format --check-formatted", "credo --strict"],
      "lint.fix": ["format", "credo --strict --auto-gen-config"],
      security: ["sobelow --config"],
      quality: ["lint", "dialyzer", "security", "test"],
      ci: ["quality", "coveralls.html"]
    ]
  end

  defp releases do
    [
      my_phoenix_app: [
        include_executables_for: [:unix],
        applications: [runtime_tools: :permanent],
        steps: [:assemble, :tar]
      ]
    ]
  end
end]]></correct-example>
          <incorrect-example title="Poor Mix configuration" conditions="Configuring Mix for Elixir project" expected-result="Efficient build and development workflow" incorrectness-criteria="Missing dependencies, no aliases, poor environment setup"><![CDATA[# mix.exs
defmodule MyApp.MixProject do
  use Mix.Project

  def project do
    [
      app: :my_app,
      version: "0.1.0",
      elixir: "~> 1.14",
      deps: deps()
    ]
  end

  def application do
    [
      extra_applications: [:logger]
    ]
  end

  defp deps do
    [
      {:phoenix, "~> 1.7"}
    ]
  end
end

# Problems:
# - Missing essential dependencies
# - No proper aliases for development
# - No environment-specific configuration
# - Missing testing and quality tools
# - No release configuration]]></incorrect-example>
        </example>
      </examples>
    </requirement>

    <requirement priority="critical">
      <description>Configure Credo for comprehensive code analysis with project-specific rules and consistent code quality enforcement.</description>
      <examples>
        <example title="Credo Configuration">
          <correct-example title="Proper Credo setup" conditions="Setting up code quality checks" expected-result="Comprehensive code analysis and quality enforcement" correctness-criteria="Uses proper Credo configuration with project-specific rules and comprehensive checks"><![CDATA[# .credo.exs
%{
  configs: [
    %{
      name: "default",
      files: %{
        included: [
          "lib/",
          "src/",
          "test/",
          "web/",
          "apps/*/lib/",
          "apps/*/test/"
        ],
        excluded: [
          ~r"/_build/",
          ~r"/deps/",
          ~r"/node_modules/",
          "lib/my_phoenix_app_web/controllers/page_controller.ex"
        ]
      },
      plugins: [],
      requires: [],
      strict: true,
      parse_timeout: 10_000,
      color: true,
      checks: %{
        enabled: [
          # Consistency Checks
          {Credo.Check.Consistency.ExceptionNames, []},
          {Credo.Check.Consistency.LineEndings, []},
          {Credo.Check.Consistency.ParameterPatternMatching, []},
          {Credo.Check.Consistency.SpaceAroundOperators, []},
          {Credo.Check.Consistency.SpaceInParentheses, []},
          {Credo.Check.Consistency.TabsOrSpaces, []},

          # Design Checks
          {Credo.Check.Design.AliasUsage,
           [priority: :low, if_nested_deeper_than: 2, if_called_more_often_than: 0]},
          {Credo.Check.Design.TagFIXME, []},
          {Credo.Check.Design.TagTODO, [exit_status: 2]},

          # Readability Checks
          {Credo.Check.Readability.AliasOrder, []},
          {Credo.Check.Readability.FunctionNames, []},
          {Credo.Check.Readability.LargeNumbers, []},
          {Credo.Check.Readability.MaxLineLength, [priority: :low, max_length: 120]},
          {Credo.Check.Readability.ModuleAttributeNames, []},
          {Credo.Check.Readability.ModuleDoc, [ignore_names: [".*Endpoint$", ".*Router$", ".*View$"]]},
          {Credo.Check.Readability.ModuleNames, []},
          {Credo.Check.Readability.ParenthesesInCondition, []},
          {Credo.Check.Readability.ParenthesesOnZeroArityDefs, []},
          {Credo.Check.Readability.PipeIntoAnonymousFunctions, []},
          {Credo.Check.Readability.PredicateFunctionNames, []},
          {Credo.Check.Readability.PreferImplicitTry, []},
          {Credo.Check.Readability.RedundantBlankLines, []},
          {Credo.Check.Readability.Semicolons, []},
          {Credo.Check.Readability.SpaceAfterCommas, []},
          {Credo.Check.Readability.StringSigils, []},
          {Credo.Check.Readability.TrailingBlankLine, []},
          {Credo.Check.Readability.TrailingWhiteSpace, []},
          {Credo.Check.Readability.UnnecessaryAliasExpansion, []},
          {Credo.Check.Readability.VariableNames, []},
          {Credo.Check.Readability.WithSingleClause, []},

          # Refactoring Opportunities
          {Credo.Check.Refactor.Apply, []},
          {Credo.Check.Refactor.CondStatements, []},
          {Credo.Check.Refactor.CyclomaticComplexity, [max_complexity: 10]},
          {Credo.Check.Refactor.FunctionArity, [max_arity: 5]},
          {Credo.Check.Refactor.LongQuoteBlocks, []},
          {Credo.Check.Refactor.MapInto, []},
          {Credo.Check.Refactor.MatchInCondition, []},
          {Credo.Check.Refactor.NegatedConditionsInUnless, []},
          {Credo.Check.Refactor.NegatedConditionsWithElse, []},
          {Credo.Check.Refactor.Nesting, [max_nesting: 3]},
          {Credo.Check.Refactor.UnlessWithElse, []},
          {Credo.Check.Refactor.WithClauses, []},

          # Warning Checks
          {Credo.Check.Warning.ApplicationConfigInModuleAttribute, []},
          {Credo.Check.Warning.BoolOperationOnSameValues, []},
          {Credo.Check.Warning.ExpensiveEmptyEnumCheck, []},
          {Credo.Check.Warning.IExPry, []},
          {Credo.Check.Warning.IoInspect, []},
          {Credo.Check.Warning.LazyLogging, []},
          {Credo.Check.Warning.MixEnv, false},
          {Credo.Check.Warning.OperationOnSameValues, []},
          {Credo.Check.Warning.OperationWithConstantResult, []},
          {Credo.Check.Warning.RaiseInsideRescue, []},
          {Credo.Check.Warning.SpecWithStruct, []},
          {Credo.Check.Warning.WrongTestFileExtension, []},
          {Credo.Check.Warning.UnusedEnumOperation, []},
          {Credo.Check.Warning.UnusedFileOperation, []},
          {Credo.Check.Warning.UnusedKeywordOperation, []},
          {Credo.Check.Warning.UnusedListOperation, []},
          {Credo.Check.Warning.UnusedPathOperation, []},
          {Credo.Check.Warning.UnusedRegexOperation, []},
          {Credo.Check.Warning.UnusedStringOperation, []},
          {Credo.Check.Warning.UnusedTupleOperation, []},
          {Credo.Check.Warning.UnsafeExec, []}
        ],
        disabled: [
          # Checks scheduled for next check update (opt-in for now)
          {Credo.Check.Refactor.UtcNowTruncate, []},

          # Controversial and experimental checks (opt-in, just replace `false` with `[]`)
          {Credo.Check.Consistency.MultiAliasImportRequireUse, false},
          {Credo.Check.Consistency.UnusedVariableNames, false},
          {Credo.Check.Design.DuplicatedCode, false},
          {Credo.Check.Design.SkipTestWithoutComment, false},
          {Credo.Check.Readability.AliasAs, false},
          {Credo.Check.Readability.BlockPipe, false},
          {Credo.Check.Readability.ImplTrue, false},
          {Credo.Check.Readability.MultiAlias, false},
          {Credo.Check.Readability.NestedFunctionCalls, false},
          {Credo.Check.Readability.OneArityFunctionInPipe, false},
          {Credo.Check.Readability.OnePipePerLine, false},
          {Credo.Check.Readability.SeparateAliasRequire, false},
          {Credo.Check.Readability.SingleFunctionToBlockPipe, false},
          {Credo.Check.Readability.SinglePipe, false},
          {Credo.Check.Readability.Specs, false},
          {Credo.Check.Readability.StrictModuleLayout, false},
          {Credo.Check.Readability.WithCustomTaggedTuple, false},
          {Credo.Check.Refactor.ABCSize, false},
          {Credo.Check.Refactor.AppendSingleItem, false},
          {Credo.Check.Refactor.DoubleBooleanNegation, false},
          {Credo.Check.Refactor.FilterReject, false},
          {Credo.Check.Refactor.IoPuts, false},
          {Credo.Check.Refactor.MapJoin, false},
          {Credo.Check.Refactor.NegatedIsNil, false},
          {Credo.Check.Refactor.PipeChainStart, false},
          {Credo.Check.Refactor.RejectReject, false},
          {Credo.Check.Refactor.VariableRebinding, false},
          {Credo.Check.Warning.LeakyEnvironment, false},
          {Credo.Check.Warning.MapGetUnsafePass, false},
          {Credo.Check.Warning.UnsafeToAtom, false}
        ]
      }
    }
  ]
}]]></correct-example>
          <incorrect-example title="Poor Credo configuration" conditions="Setting up code quality checks" expected-result="Comprehensive code analysis and quality enforcement" incorrectness-criteria="Basic configuration, missing checks, no project-specific rules"><![CDATA[# .credo.exs
%{
  configs: [
    %{
      name: "default",
      files: %{
        included: ["lib/"]
      },
      checks: [
        {Credo.Check.Readability.ModuleDoc, false}
      ]
    }
  ]
}

# Problems:
# - Missing comprehensive file inclusion
# - Not using proper check categories
# - No project-specific customization
# - Missing important quality checks
# - No proper strictness configuration]]></incorrect-example>
        </example>
      </examples>
    </requirement>

    <requirement priority="critical">
      <description>Configure Elixir formatter with proper formatting rules and import/alias organization for consistent code style.</description>
      <examples>
        <example title="Formatter Configuration">
          <correct-example title="Proper formatter setup" conditions="Setting up code formatting" expected-result="Consistent code formatting across project" correctness-criteria="Uses proper formatter configuration with import deps and custom rules"><![CDATA[# .formatter.exs
[
  import_deps: [:ecto, :ecto_sql, :phoenix, :plug, :absinthe],
  subdirectories: ["priv/*/migrations"],
  plugins: [Phoenix.LiveView.HTMLFormatter],
  inputs: [
    "*.{heex,ex,exs}",
    "{config,lib,test}/**/*.{heex,ex,exs}",
    "priv/*/seeds.exs"
  ],
  line_length: 100,
  locals_without_parens: [
    # Phoenix
    plug: :*,
    action_fallback: 1,
    render: :*,
    redirect: 1,
    
    # Phoenix Router
    get: :*,
    post: :*,
    put: :*,
    patch: :*,
    delete: :*,
    head: :*,
    options: :*,
    forward: :*,
    scope: :*,
    pipe_through: 1,
    resources: :*,
    live: :*,
    live_session: :*,
    
    # Phoenix LiveView
    assign: :*,
    assign_new: :*,
    push_event: :*,
    push_patch: :*,
    push_redirect: :*,
    
    # Ecto
    field: :*,
    belongs_to: :*,
    has_one: :*,
    has_many: :*,
    many_to_many: :*,
    embeds_one: :*,
    embeds_many: :*,
    timestamps: :*,
    
    # Ecto Migrations
    create: :*,
    alter: :*,
    drop: :*,
    rename: :*,
    add: :*,
    remove: :*,
    modify: :*,
    create_if_not_exists: :*,
    drop_if_exists: :*,
    
    # ExUnit
    describe: 2,
    test: :*,
    setup: :*,
    setup_all: :*,
    
    # Oban
    use_oban: :*,
    
    # Custom project macros
    defcontext: 2,
    defdelegates: 2
  ]
]

# For Umbrella projects - .formatter.exs in umbrella root
[
  import_deps: [],
  subdirectories: ["apps/*"],
  inputs: []
]

# For individual apps in umbrella - apps/my_app/.formatter.exs
[
  import_deps: [:ecto, :ecto_sql, :phoenix],
  inputs: ["*.{ex,exs}", "{config,lib,test}/**/*.{ex,exs}"],
  line_length: 100
]]]></correct-example>
          <incorrect-example title="Poor formatter configuration" conditions="Setting up code formatting" expected-result="Consistent code formatting across project" incorrectness-criteria="Basic configuration, missing import deps, no custom rules"><![CDATA[# .formatter.exs
[
  inputs: ["*.{ex,exs}", "{config,lib,test}/**/*.{ex,exs}"]
]

# Problems:
# - Missing import_deps for proper macro formatting
# - No line length specification
# - Missing subdirectories for migrations
# - No locals_without_parens customization
# - No framework-specific configuration]]></incorrect-example>
        </example>
      </examples>
    </requirement>

    <requirement priority="high">
      <description>Configure proper environment-based configuration with runtime configuration and secure secret management.</description>
      <examples>
        <example title="Environment Configuration">
          <correct-example title="Proper environment setup" conditions="Configuring application environments" expected-result="Secure and flexible environment configuration" correctness-criteria="Uses proper config files, runtime configuration, and secret management"><![CDATA[# config/config.exs
import Config

config :my_phoenix_app,
  ecto_repos: [MyPhoenixApp.Repo],
  generators: [timestamp_type: :utc_datetime]

config :my_phoenix_app_web,
  ecto_repos: [MyPhoenixApp.Repo],
  generators: [context_app: :my_phoenix_app]

# Configures the endpoint
config :my_phoenix_app_web, MyPhoenixAppWeb.Endpoint,
  url: [host: "localhost"],
  adapter: Phoenix.Endpoint.Cowboy2Adapter,
  render_errors: [
    formats: [html: MyPhoenixAppWeb.ErrorHTML, json: MyPhoenixAppWeb.ErrorJSON],
    layout: false
  ],
  pubsub_server: MyPhoenixApp.PubSub,
  live_view: [signing_salt: "your-signing-salt"]

# Configure esbuild
config :esbuild,
  version: "0.17.11",
  default: [
    args:
      ~w(js/app.js --bundle --target=es2017 --outdir=../priv/static/assets --external:/fonts/* --external:/images/*),
    cd: Path.expand("../assets", __DIR__),
    env: %{"NODE_PATH" => Path.expand("../deps", __DIR__)}
  ]

# Configure tailwind
config :tailwind,
  version: "3.3.0",
  default: [
    args: ~w(
      --config=tailwind.config.js
      --input=css/app.css
      --output=../priv/static/assets/app.css
    ),
    cd: Path.expand("../assets", __DIR__)
  ]

# Configures Elixir's Logger
config :logger, :console,
  format: "$time $metadata[$level] $message\n",
  metadata: [:request_id]

# Use Jason for JSON parsing in Phoenix
config :phoenix, :json_library, Jason

# Oban configuration
config :my_phoenix_app, Oban,
  repo: MyPhoenixApp.Repo,
  plugins: [Oban.Plugins.Pruner],
  queues: [default: 10, events: 50, media: 5]

# Import environment specific config
import_config "#{config_env()}.exs"

# config/dev.exs
import Config

# Configure your database
config :my_phoenix_app, MyPhoenixApp.Repo,
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  database: "my_phoenix_app_dev",
  stacktrace: true,
  show_sensitive_data_on_connection_error: true,
  pool_size: 10

config :my_phoenix_app_web, MyPhoenixAppWeb.Endpoint,
  http: [ip: {127, 0, 0, 1}, port: 4000],
  check_origin: false,
  code_reloader: true,
  debug_errors: true,
  secret_key_base: "development-secret-key-base-change-me",
  watchers: [
    esbuild: {Esbuild, :install_and_run, [:default, ~w(--sourcemap=inline --watch)]},
    tailwind: {Tailwind, :install_and_run, [:default, ~w(--watch)]}
  ]

config :my_phoenix_app_web, MyPhoenixAppWeb.Endpoint,
  live_reload: [
    patterns: [
      ~r"priv/static/.*(js|css|png|jpeg|jpg|gif|svg)$",
      ~r"priv/gettext/.*(po)$",
      ~r"lib/my_phoenix_app_web/(controllers|live|components)/.*(ex|heex)$"
    ]
  ]

# Enable dev routes for dashboard and mailbox
config :my_phoenix_app_web, dev_routes: true

# Do not include metadata nor timestamps in development logs
config :logger, :console, format: "[$level] $message\n"

# Set a higher stacktrace during development
config :phoenix, :stacktrace_depth, 20

# Initialize plugs at runtime for faster development compilation
config :phoenix, :plug_init_mode, :runtime

# config/prod.exs
import Config

config :my_phoenix_app, MyPhoenixApp.Repo, pool_size: 20

config :my_phoenix_app_web, MyPhoenixAppWeb.Endpoint,
  cache_static_manifest: "priv/static/cache_manifest.json",
  server: true

# Configures Swoosh API Client
config :swoosh, api_client: Swoosh.ApiClient.Finch, finch_name: MyPhoenixApp.Finch

# Disable Swoosh Local Memory Storage
config :swoosh, local: false

# Do not print debug messages in production
config :logger, level: :info

# Runtime production configuration, including reading
# of environment variables, is done on config/runtime.exs.

# config/runtime.exs
import Config

# config/runtime.exs is executed for all environments, including
# during releases. It is executed after compilation and before the
# system starts, so it is typically used to load production configuration
# and secrets from environment variables or elsewhere.

if config_env() == :prod do
  database_url =
    System.get_env("DATABASE_URL") ||
      raise """
      environment variable DATABASE_URL is missing.
      For example: ecto://USER:PASS@HOST/DATABASE
      """

  maybe_ipv6 = if System.get_env("ECTO_IPV6") in ~w(true 1), do: [:inet6], else: []

  config :my_phoenix_app, MyPhoenixApp.Repo,
    url: database_url,
    pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10"),
    socket_options: maybe_ipv6

  secret_key_base =
    System.get_env("SECRET_KEY_BASE") ||
      raise """
      environment variable SECRET_KEY_BASE is missing.
      """

  host = System.get_env("PHX_HOST") || "example.com"
  port = String.to_integer(System.get_env("PORT") || "4000")

  config :my_phoenix_app_web, MyPhoenixAppWeb.Endpoint,
    url: [host: host, port: 443, scheme: "https"],
    http: [
      ip: {0, 0, 0, 0, 0, 0, 0, 0},
      port: port
    ],
    secret_key_base: secret_key_base

  # Configure Swoosh for production email
  config :my_phoenix_app, MyPhoenixApp.Mailer,
    adapter: Swoosh.Adapters.Mailgun,
    api_key: System.get_env("MAILGUN_API_KEY"),
    domain: System.get_env("MAILGUN_DOMAIN")

  # Configure Redis for Oban
  config :my_phoenix_app, Oban,
    repo: MyPhoenixApp.Repo,
    plugins: [
      Oban.Plugins.Pruner,
      {Oban.Plugins.Cron,
       crontab: [
         {"0 2 * * *", MyPhoenixApp.Workers.DailyDigestWorker},
         {"0 */6 * * *", MyPhoenixApp.Workers.StatsWorker}
       ]}
    ],
    queues: [default: 10, events: 50, media: 20]
end

# config/test.exs
import Config

# Configure your database
config :my_phoenix_app, MyPhoenixApp.Repo,
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  database: "my_phoenix_app_test#{System.get_env("MIX_TEST_PARTITION")}",
  pool: Ecto.Adapters.SQL.Sandbox,
  pool_size: 10

config :my_phoenix_app_web, MyPhoenixAppWeb.Endpoint,
  http: [ip: {127, 0, 0, 1}, port: 4002],
  secret_key_base: "test-secret-key-base",
  server: false

# In test we don't send emails
config :my_phoenix_app, MyPhoenixApp.Mailer, adapter: Swoosh.Adapters.Test

# Disable swoosh api client as it is only required for production adapters
config :swoosh, :api_client, false

# Print only warnings and errors during test
config :logger, level: :warning

# Initialize plugs at runtime for faster test compilation
config :phoenix, :plug_init_mode, :runtime

# Configure Oban for testing
config :my_phoenix_app, Oban, testing: :inline]]></correct-example>
          <incorrect-example title="Poor environment configuration" conditions="Configuring application environments" expected-result="Secure and flexible environment configuration" incorrectness-criteria="Hardcoded values, insecure secrets, no environment separation"><![CDATA[# config/config.exs
import Config

config :my_app, MyApp.Repo,
  username: "postgres",
  password: "postgres",
  database: "my_app_prod",
  hostname: "localhost"

config :my_app, MyAppWeb.Endpoint,
  secret_key_base: "hardcoded-secret-key",
  url: [host: "localhost", port: 4000]

# Problems:
# - Hardcoded database credentials
# - Same config for all environments
# - Insecure secret key management
# - No runtime configuration
# - Missing environment-specific settings]]></incorrect-example>
        </example>
      </examples>
    </requirement>

    <requirement priority="high">
      <description>Configure proper testing setup with ExUnit, test helpers, and comprehensive test coverage using ExCoveralls.</description>
      <examples>
        <example title="Testing Configuration">
          <correct-example title="Proper testing setup" conditions="Setting up comprehensive testing" expected-result="Robust testing infrastructure" correctness-criteria="Uses ExUnit with proper helpers, coverage, and testing patterns"><![CDATA[# test/test_helper.exs
ExUnit.start()
Ecto.Adapters.SQL.Sandbox.mode(MyPhoenixApp.Repo, :manual)

# test/support/fixtures/accounts_fixtures.ex
defmodule MyPhoenixApp.AccountsFixtures do
  @moduledoc """
  This module defines test helpers for creating
  entities via the `MyPhoenixApp.Accounts` context.
  """

  def unique_user_email, do: "user#{System.unique_integer()}@example.com"
  def valid_user_password, do: "hello world!"

  def valid_user_attributes(attrs \\ %{}) do
    Enum.into(attrs, %{
      email: unique_user_email(),
      password: valid_user_password()
    })
  end

  def user_fixture(attrs \\ %{}) do
    {:ok, user} =
      attrs
      |> valid_user_attributes()
      |> MyPhoenixApp.Accounts.register_user()

    user
  end

  def extract_user_token(fun) do
    {:ok, captured_email} = fun.(&"[TOKEN]#{&1}[TOKEN]")
    [_, token | _] = String.split(captured_email.text_body, "[TOKEN]")
    token
  end
end

# test/support/conn_case.ex
defmodule MyPhoenixAppWeb.ConnCase do
  @moduledoc """
  This module defines the test case to be used by
  tests that require setting up a connection.
  """

  use ExUnit.CaseTemplate

  using do
    quote do
      # The default endpoint for testing
      @endpoint MyPhoenixAppWeb.Endpoint

      use MyPhoenixAppWeb, :verified_routes

      # Import conveniences for testing with connections
      import Plug.Conn
      import Phoenix.ConnTest
      import MyPhoenixAppWeb.ConnCase
    end
  end

  setup tags do
    MyPhoenixApp.DataCase.setup_sandbox(tags)
    {:ok, conn: Phoenix.ConnTest.build_conn()}
  end

  @doc """
  Setup helper that registers and logs in users.

      setup :register_and_log_in_user

  It stores an updated connection and a registered user in the
  test context.
  """
  def register_and_log_in_user(%{conn: conn}) do
    user = MyPhoenixApp.AccountsFixtures.user_fixture()
    %{conn: log_in_user(conn, user), user: user}
  end

  @doc """
  Logs the given `user` into the `conn`.

  It returns an updated `conn`.
  """
  def log_in_user(conn, user) do
    token = MyPhoenixApp.Accounts.generate_user_session_token(user)

    conn
    |> Phoenix.ConnTest.init_test_session(%{})
    |> Plug.Conn.put_session(:user_token, token)
  end
end

# test/support/data_case.ex
defmodule MyPhoenixApp.DataCase do
  @moduledoc """
  This module defines the setup for tests requiring
  access to the application's data layer.
  """

  use ExUnit.CaseTemplate

  using do
    quote do
      alias MyPhoenixApp.Repo

      import Ecto
      import Ecto.Changeset
      import Ecto.Query
      import MyPhoenixApp.DataCase
    end
  end

  setup tags do
    MyPhoenixApp.DataCase.setup_sandbox(tags)
    :ok
  end

  @doc """
  Sets up the sandbox based on the test tags.
  """
  def setup_sandbox(tags) do
    pid = Ecto.Adapters.SQL.Sandbox.start_owner!(MyPhoenixApp.Repo, shared: not tags[:async])
    on_exit(fn -> Ecto.Adapters.SQL.Sandbox.stop_owner(pid) end)
  end

  @doc """
  A helper that transforms changeset errors into a map of messages.

      assert {:error, changeset} = Accounts.create_user(%{password: "short"})
      assert "password is too short" in errors_on(changeset).password
      assert %{password: ["password is too short"]} = errors_on(changeset)

  """
  def errors_on(changeset) do
    Ecto.Changeset.traverse_errors(changeset, fn {message, opts} ->
      Regex.replace(~r"%{(\w+)}", message, fn _, key ->
        opts |> Keyword.get(String.to_existing_atom(key), key) |> to_string()
      end)
    end)
  end
end

# test/support/channel_case.ex
defmodule MyPhoenixAppWeb.ChannelCase do
  @moduledoc """
  This module defines the test case to be used by
  channel tests.
  """

  use ExUnit.CaseTemplate

  using do
    quote do
      # Import conveniences for testing with channels
      import Phoenix.ChannelTest
      import MyPhoenixAppWeb.ChannelCase

      # The default endpoint for testing
      @endpoint MyPhoenixAppWeb.Endpoint
    end
  end

  setup tags do
    MyPhoenixApp.DataCase.setup_sandbox(tags)
    :ok
  end
end

# Example test file - test/my_phoenix_app/accounts_test.exs
defmodule MyPhoenixApp.AccountsTest do
  use MyPhoenixApp.DataCase

  alias MyPhoenixApp.Accounts

  import MyPhoenixApp.AccountsFixtures

  describe "get_user_by_email/1" do
    test "does not return the user if the email does not exist" do
      refute Accounts.get_user_by_email("unknown@example.com")
    end

    test "returns the user if the email exists" do
      %{id: id} = user = user_fixture()
      assert %{id: ^id} = Accounts.get_user_by_email(user.email)
    end
  end

  describe "get_user_by_email_and_password/2" do
    test "does not return the user if the email does not exist" do
      refute Accounts.get_user_by_email_and_password("unknown@example.com", "hello world!")
    end

    test "does not return the user if the password is not valid" do
      user = user_fixture()
      refute Accounts.get_user_by_email_and_password(user.email, "invalid")
    end

    test "returns the user if the email and password are valid" do
      %{id: id} = user = user_fixture()

      assert %{id: ^id} =
               Accounts.get_user_by_email_and_password(user.email, valid_user_password())
    end
  end
end

# Mix configuration for coverage - in mix.exs
def project do
  [
    # ... other config
    test_coverage: [tool: ExCoveralls],
    preferred_cli_env: [
      coveralls: :test,
      "coveralls.detail": :test,
      "coveralls.post": :test,
      "coveralls.html": :test,
      "coveralls.github": :test
    ]
  ]
end

# .coveralls.exs
%{
  "coverage_options" => %{
    "treat_no_relevant_lines_as_covered" => true,
    "output_dir" => "cover/",
    "template_path" => "cover/coverage.html.eex"
  },
  "terminal_options" => %{
    "file_column_width" => 40
  },
  "html_options" => %{
    "title" => "MyPhoenixApp Coverage Report"
  }
}]]></correct-example>
          <incorrect-example title="Poor testing setup" conditions="Setting up comprehensive testing" expected-result="Robust testing infrastructure" incorrectness-criteria="Basic ExUnit setup, no helpers, missing coverage"><![CDATA[# test/test_helper.exs
ExUnit.start()

# test/my_app_test.exs
defmodule MyAppTest do
  use ExUnit.Case

  test "greets the world" do
    assert MyApp.hello() == :world
  end
end

# Problems:
# - No database sandbox setup
# - Missing test support files
# - No fixtures or factories
# - No coverage configuration
# - No proper test organization]]></incorrect-example>
        </example>
      </examples>
    </requirement>

    <requirement priority="high">
      <description>Configure proper documentation with ExDoc, comprehensive module documentation, and API documentation generation.</description>
      <examples>
        <example title="Documentation Configuration">
          <correct-example title="Proper documentation setup" conditions="Setting up project documentation" expected-result="Comprehensive and maintainable documentation" correctness-criteria="Uses ExDoc with proper configuration and comprehensive module docs"><![CDATA[# In mix.exs
defmodule MyPhoenixApp.MixProject do
  use Mix.Project

  def project do
    [
      # ... other config
      name: "MyPhoenixApp",
      source_url: "https://github.com/my_org/my_phoenix_app",
      homepage_url: "https://my_phoenix_app.com",
      docs: docs()
    ]
  end

  defp docs do
    [
      main: "MyPhoenixApp",
      logo: "assets/static/images/logo.png",
      source_ref: "v#{@version}",
      source_url: "https://github.com/my_org/my_phoenix_app",
      extras: [
        "README.md",
        "CHANGELOG.md": [title: "Changelog"],
        "docs/deployment.md": [title: "Deployment Guide"],
        "docs/api-guide.md": [title: "API Guide"],
        "docs/architecture.md": [title: "Architecture"]
      ],
      groups_for_extras: [
        "Guides": ~r/docs\/.?/
      ],
      groups_for_modules: [
        "Contexts": [
          MyPhoenixApp.Accounts,
          MyPhoenixApp.Blog,
          MyPhoenixApp.Content
        ],
        "Web": [
          MyPhoenixAppWeb.Endpoint,
          MyPhoenixAppWeb.Router,
          MyPhoenixAppWeb.Telemetry
        ],
        "Controllers": ~r/MyPhoenixAppWeb.*Controller/,
        "Live Views": ~r/MyPhoenixAppWeb.*Live/,
        "Components": ~r/MyPhoenixAppWeb.*Component/,
        "Workers": ~r/MyPhoenixApp.*Worker/
      ],
      groups_for_functions: [
        "Queries": &(&1[:type] == :query),
        "Mutations": &(&1[:type] == :mutation),
        "Validations": &(&1[:type] == :validation)
      ]
    ]
  end

  # Example of proper module documentation
  defmodule MyPhoenixApp.Accounts do
    @moduledoc """
    The Accounts context.

    This context handles user authentication, authorization, and user management.
    It provides functions for registering users, authenticating them, and managing
    their sessions and tokens.

    ## Examples

        iex> list_users()
        [%User{}, ...]

        iex> get_user!(123)
        %User{}

        iex> create_user(%{field: value})
        {:ok, %User{}}

        iex> update_user(user, %{field: new_value})
        {:ok, %User{}}

        iex> delete_user(user)
        {:ok, %User{}}

        iex> change_user(user)
        %Ecto.Changeset{data: %User{}}

    """

    import Ecto.Query, warn: false
    alias MyPhoenixApp.Repo
    alias MyPhoenixApp.Accounts.{User, UserToken, UserNotifier}

    @doc """
    Returns the list of users.

    ## Examples

        iex> list_users()
        [%User{}, ...]

    """
    @spec list_users() :: [User.t()]
    def list_users do
      Repo.all(User)
    end

    @doc """
    Gets a single user.

    Raises `Ecto.NoResultsError` if the User does not exist.

    ## Examples

        iex> get_user!(123)
        %User{}

        iex> get_user!(456)
        ** (Ecto.NoResultsError)

    """
    @spec get_user!(integer()) :: User.t()
    def get_user!(id), do: Repo.get!(User, id)

    @doc """
    Creates a user.

    ## Examples

        iex> create_user(%{field: value})
        {:ok, %User{}}

        iex> create_user(%{field: bad_value})
        {:error, %Ecto.Changeset{}}

    """
    @spec create_user(map()) :: {:ok, User.t()} | {:error, Ecto.Changeset.t()}
    def create_user(attrs \\ %{}) do
      %User{}
      |> User.changeset(attrs)
      |> Repo.insert()
    end

    @doc """
    Updates a user.

    ## Examples

        iex> update_user(user, %{field: new_value})
        {:ok, %User{}}

        iex> update_user(user, %{field: bad_value})
        {:error, %Ecto.Changeset{}}

    """
    @spec update_user(User.t(), map()) :: {:ok, User.t()} | {:error, Ecto.Changeset.t()}
    def update_user(%User{} = user, attrs) do
      user
      |> User.changeset(attrs)
      |> Repo.update()
    end

    @doc """
    Deletes a user.

    ## Examples

        iex> delete_user(user)
        {:ok, %User{}}

        iex> delete_user(user)
        {:error, %Ecto.Changeset{}}

    """
    @spec delete_user(User.t()) :: {:ok, User.t()} | {:error, Ecto.Changeset.t()}
    def delete_user(%User{} = user) do
      Repo.delete(user)
    end

    @doc """
    Returns an `%Ecto.Changeset{}` for tracking user changes.

    ## Examples

        iex> change_user(user)
        %Ecto.Changeset{data: %User{}}

    """
    @spec change_user(User.t(), map()) :: Ecto.Changeset.t()
    def change_user(%User{} = user, attrs \\ %{}) do
      User.changeset(user, attrs)
    end
  end

  # README.md structure
  # MyPhoenixApp

  A modern Phoenix application built with Elixir.

  ## Features

  - User authentication and authorization
  - Real-time features with LiveView
  - Background job processing with Oban
  - Comprehensive testing suite
  - Docker support for deployment

  ## Requirements

  - Elixir 1.14+
  - Phoenix 1.7+
  - PostgreSQL 14+
  - Node.js 18+ (for assets)

  ## Getting Started

  ### Development Setup

  1. Clone the repository:
     ```bash
     git clone https://github.com/my_org/my_phoenix_app.git
     cd my_phoenix_app
     ```

  2. Install dependencies:
     ```bash
     mix deps.get
     cd assets && npm install && cd ..
     ```

  3. Setup database:
     ```bash
     mix ecto.setup
     ```

  4. Start the server:
     ```bash
     mix phx.server
     ```

  Visit [`localhost:4000`](http://localhost:4000) to see the application.

  ## Documentation

  - [API Documentation](https://hexdocs.pm/my_phoenix_app)
  - [Deployment Guide](docs/deployment.md)
  - [Architecture Overview](docs/architecture.md)

  ## Testing

  ```bash
  # Run all tests
  mix test

  # Run tests with coverage
  mix coveralls.html

  # Run quality checks
  mix quality
  ```

  ## Deployment

  See [Deployment Guide](docs/deployment.md) for detailed instructions.

  ## Contributing

  1. Fork it
  2. Create your feature branch (`git checkout -b my-new-feature`)
  3. Commit your changes (`git commit -am 'Add some feature'`)
  4. Push to the branch (`git push origin my-new-feature`)
  5. Create new Pull Request

  ## License

  This project is licensed under the MIT License.]]></correct-example>
          <incorrect-example title="Poor documentation setup" conditions="Setting up project documentation" expected-result="Comprehensive and maintainable documentation" incorrectness-criteria="Missing ExDoc configuration, poor module docs, no README"><![CDATA[# No ExDoc configuration in mix.exs

# Poor module documentation
defmodule MyApp.Accounts do
  def list_users do
    # No documentation
  end
  
  def get_user!(id), do: Repo.get!(User, id)
  
  def create_user(attrs) do
    # No examples or type specs
  end
end

# Basic README.md
# MyApp

An Elixir app.

## Installation

mix deps.get

# Problems:
# - No ExDoc configuration
# - Missing module documentation
# - No type specifications
# - Poor README structure
# - No examples or guides]]></incorrect-example>
        </example>
      </examples>
    </requirement>

    <requirement priority="medium">
      <description>Configure proper release configuration with Mix releases for production deployment and Docker containerization.</description>
      <examples>
        <example title="Release and Deployment Configuration">
          <correct-example title="Proper release setup" conditions="Setting up production deployment" expected-result="Efficient production releases" correctness-criteria="Uses Mix releases with proper configuration and Docker support"><![CDATA[# rel/env.sh.eex
#!/bin/sh

# Configure the database URL
export DATABASE_URL="${DATABASE_URL}"

# Configure the secret key base
export SECRET_KEY_BASE="${SECRET_KEY_BASE}"

# Configure the Phoenix host and port
export PHX_HOST="${PHX_HOST:-localhost}"
export PHX_PORT="${PHX_PORT:-4000}"

# In mix.exs
defp releases do
  [
    my_phoenix_app: [
      include_executables_for: [:unix],
      applications: [runtime_tools: :permanent],
      steps: [:assemble, :tar],
      config_providers: [
        {Config.Reader, {:system, "RUNTIME_CONFIG_PATH", "/app/config/runtime.exs"}}
      ]
    ]
  ]
end

# Dockerfile
FROM hexpm/elixir:1.15.7-erlang-26.1.2-alpine-3.18.4 AS build

# install build dependencies
RUN apk add --no-cache build-base npm git python3

# prepare build dir
WORKDIR /app

# install hex + rebar
RUN mix local.hex --force && \
    mix local.rebar --force

# set build ENV
ENV MIX_ENV=prod

# install mix dependencies
COPY mix.exs mix.lock ./
RUN mix deps.get --only=prod
RUN mkdir config

# copy compile-time config files before we compile dependencies
# to ensure any relevant config change will trigger the dependencies
# to be re-compiled.
COPY config/config.exs config/prod.exs config/
RUN mix deps.compile

COPY priv priv

COPY assets assets
COPY lib lib

# compile assets
RUN mix assets.deploy

# Compile the release
RUN mix compile

# Changes to config/runtime.exs don't require recompiling the code
COPY config/runtime.exs config/

COPY rel rel
RUN mix release

# start a new build stage so that the final image will only contain
# the compiled release and other runtime necessities
FROM alpine:3.18.4 AS app
RUN apk add --no-cache libstdc++ openssl ncurses-libs

WORKDIR /app
RUN chown nobody /app

# Only copy the final release from the build stage
COPY --from=build --chown=nobody:root /app/_build/prod/rel/my_phoenix_app ./

USER nobody

# If using a startup script, copy it over
# COPY --from=build --chown=nobody:root /app/bin/server /app/bin/server
# CMD ["/app/bin/server"]

CMD ["/app/bin/my_phoenix_app", "start"]

# docker-compose.yml for development
version: '3.8'

services:
  web:
    build: .
    ports:
      - "4000:4000"
    environment:
      - DATABASE_URL=ecto://postgres:postgres@db/my_phoenix_app_dev
      - SECRET_KEY_BASE=your-secret-key-base
      - PHX_HOST=localhost
    depends_on:
      - db
    volumes:
      - .:/app
      - /app/deps
      - /app/_build

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=my_phoenix_app_dev
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  postgres_data:

# docker-compose.prod.yml for production
version: '3.8'

services:
  web:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "4000:4000"
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - SECRET_KEY_BASE=${SECRET_KEY_BASE}
      - PHX_HOST=${PHX_HOST}
      - PHX_PORT=4000
    depends_on:
      - db

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:

# GitHub Actions workflow - .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  MIX_ENV: test

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Elixir
      uses: erlef/setup-beam@v1
      with:
        elixir-version: '1.15.7'
        otp-version: '26.1'
        
    - name: Restore dependencies cache
      uses: actions/cache@v3
      with:
        path: deps
        key: ${{ runner.os }}-mix-${{ hashFiles('**/mix.lock') }}
        restore-keys: ${{ runner.os }}-mix-
        
    - name: Install dependencies
      run: mix deps.get
      
    - name: Check Formatting
      run: mix format --check-formatted
      
    - name: Run Credo
      run: mix credo --strict
      
    - name: Run Security Analysis
      run: mix sobelow --config
      
    - name: Run tests
      run: mix test
      
    - name: Generate coverage report
      run: mix coveralls.github
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}]]></correct-example>
          <incorrect-example title="Poor release configuration" conditions="Setting up production deployment" expected-result="Efficient production releases" incorrectness-criteria="No release configuration, missing Docker setup, poor CI"><![CDATA[# No release configuration in mix.exs

# Basic Dockerfile
FROM elixir:latest
WORKDIR /app
COPY . .
RUN mix deps.get
RUN mix compile
CMD ["mix", "phx.server"]

# No proper CI/CD
# No environment configuration
# No production optimizations

# Problems:
# - No Mix release configuration
# - Poor Docker optimization
# - Missing production environment setup
# - No CI/CD pipeline
# - Insecure container configuration]]></incorrect-example>
        </example>
      </examples>
    </requirement>
  </requirements>

  <context description="Elixir and Phoenix ecosystem best practices">
    Elixir and Phoenix represent a modern approach to building scalable, fault-tolerant applications. The Elixir ecosystem emphasizes the "let it crash" philosophy, leveraging the Actor model through lightweight processes and OTP (Open Telecom Platform) supervision trees for building resilient systems.

    Phoenix builds on these principles to provide a productive web development framework with real-time features, efficient resource usage, and excellent developer experience. The framework encourages proper separation of concerns through contexts, comprehensive testing, and following established conventions.

    Key principles for Elixir/Phoenix projects include:
    - Following official Phoenix conventions for project structure
    - Using contexts to organize business logic and maintain boundaries
    - Leveraging OTP supervision trees for fault tolerance
    - Comprehensive testing with ExUnit and proper test organization
    - Using Mix for build automation and dependency management
    - Following Elixir community standards for code quality and documentation

    Umbrella applications provide a way to organize large Elixir projects into multiple applications with clear boundaries while sharing dependencies and configuration. This approach enables better code organization, independent deployment, and team collaboration on different components.

    Modern Elixir development emphasizes proper tooling including Credo for code analysis, ExDoc for documentation, ExCoveralls for test coverage, and proper formatting with the built-in Elixir formatter.

    The ecosystem also provides excellent support for deployment through Mix releases, Docker containerization, and various cloud platforms, making it suitable for both development and production environments.
  </context>

  <references>
    <reference as="dependency" href=".cursor/rules/team-standards/cursor-rules-creation-auto.mdc" reason="Follows standard rule format">Base rule format definition</reference>
    <reference as="dependency" href=".cursor/rules/languages/elixir-conventions-auto.mdc" reason="Elixir coding conventions">Elixir coding standards and best practices</reference>
    <reference as="dependency" href=".cursor/rules/languages/elixir-testing-conventions-auto.mdc" reason="Elixir testing practices">Elixir testing conventions and patterns</reference>
    <reference as="context" href="https://hexdocs.pm/phoenix/overview.html" reason="Official Phoenix documentation">Phoenix framework guide and conventions</reference>
    <reference as="context" href="https://hexdocs.pm/elixir/introduction.html" reason="Official Elixir documentation">Elixir language documentation and guides</reference>
    <reference as="context" href="https://hexdocs.pm/mix/Mix.html" reason="Mix build tool documentation">Mix build tool and project management</reference>
    <reference as="context" href="https://github.com/rrrene/credo" reason="Credo static analysis">Credo code analysis tool for Elixir</reference>
    <reference as="context" href="https://hexdocs.pm/ex_doc/readme.html" reason="ExDoc documentation">ExDoc documentation generation tool</reference>
  </references>
</rule>
