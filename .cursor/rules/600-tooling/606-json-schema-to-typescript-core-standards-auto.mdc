---
description: "Comprehensive json-schema-to-typescript standards for generating TypeScript types from JSON Schema with validation, automation, and type safety following expert best practices"
globs: ["**/*.json", "**/*.{js,ts,mjs,cjs}", "**/schemas/**/*.json", "**/types/**/*.ts", "**/*.schema.json"]
alwaysApply: false
---

<rule>
  <meta>
    <title>JSON Schema to TypeScript Core Standards</title>
    <description>Comprehensive json-schema-to-typescript standards for generating TypeScript types from JSON Schema with validation, automation, and type safety following expert best practices</description>
    <created-at utc-timestamp="1744245220">January 27, 2025, 11:40 AM</created-at>
    <last-updated-at utc-timestamp="1744245220">January 27, 2025, 11:40 AM</last-updated-at>
    <applies-to>
      <file-matcher glob="**/*.json">JSON files including schemas</file-matcher>
      <file-matcher glob="**/*.{js,ts,mjs,cjs}">JavaScript and TypeScript files using json-schema-to-typescript</file-matcher>
      <file-matcher glob="**/schemas/**/*.json">JSON Schema definition files</file-matcher>
      <file-matcher glob="**/types/**/*.ts">Generated TypeScript type files</file-matcher>
      <file-matcher glob="**/*.schema.json">Schema files with explicit naming</file-matcher>
      <action-matcher action="type-generation">Triggered when generating TypeScript types from JSON Schema</action-matcher>
    </applies-to>
  </meta>

  <requirements>
    <non-negotiable priority="critical">
      <description>Use json-schema-to-typescript with comprehensive type generation, validation, automation, and proper TypeScript integration for type-safe development workflows.</description>
      <examples>
        <example title="Comprehensive Type Generation System">
          <correct-example title="Professional type generation with validation and automation" conditions="Generating TypeScript types from JSON Schema" expected-result="Type-safe, validated TypeScript types with proper tooling integration" correctness-criteria="Uses proper schema design, generates accurate types, includes validation, automation, error handling">// TypeScript - Comprehensive type generation service
import { compile } from 'json-schema-to-typescript';
import { promises as fs } from 'fs';
import path from 'path';
import { glob } from 'glob';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import chalk from 'chalk';
import prettier from 'prettier';

// Configuration interfaces
interface TypeGenerationConfig {
  input: {
    schemaDir: string;
    patterns: string[];
    exclude: string[];
  };
  output: {
    typeDir: string;
    indexFile: string;
    declarationMaps: boolean;
  };
  compilation: {
    bannerComment: string;
    style: {
      bracketSpacing: boolean;
      singleQuote: boolean;
      semi: boolean;
      trailingComma: 'none' | 'es5' | 'all';
    };
    strictIndexSignatures: boolean;
    unknownAny: boolean;
    unreachableDefinitions: boolean;
    enableConstEnums: boolean;
  };
  validation: {
    enabled: boolean;
    strict: boolean;
    formats: boolean;
    validateSchema: boolean;
  };
  automation: {
    watchMode: boolean;
    debounceMs: number;
    generateValidators: boolean;
    generateExamples: boolean;
  };
}

// Default configuration
const defaultConfig: TypeGenerationConfig = {
  input: {
    schemaDir: './schemas',
    patterns: ['**/*.json', '**/*.schema.json'],
    exclude: ['node_modules/**', 'dist/**']
  },
  output: {
    typeDir: './src/types',
    indexFile: 'index.ts',
    declarationMaps: true
  },
  compilation: {
    bannerComment: '/* eslint-disable */\n/**\n * This file was automatically generated by json-schema-to-typescript.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n * and run json-schema-to-typescript to regenerate this file.\n */\n',
    style: {
      bracketSpacing: true,
      singleQuote: true,
      semi: true,
      trailingComma: 'es5'
    },
    strictIndexSignatures: true,
    unknownAny: false,
    unreachableDefinitions: false,
    enableConstEnums: true
  },
  validation: {
    enabled: true,
    strict: true,
    formats: true,
    validateSchema: true
  },
  automation: {
    watchMode: false,
    debounceMs: 300,
    generateValidators: true,
    generateExamples: true
  }
};

// Professional type generation service
class TypeGenerationService {
  private config: TypeGenerationConfig;
  private ajv: Ajv;
  private schemaCache: Map<string, any> = new Map();

  constructor(config: Partial<TypeGenerationConfig> = {}) {
    this.config = { ...defaultConfig, ...config };
    this.ajv = new Ajv({ 
      strict: this.config.validation.strict,
      allErrors: true,
      verbose: true
    });
    
    if (this.config.validation.formats) {
      addFormats(this.ajv);
    }
  }

  async generateAllTypes(): Promise<void> {
    console.log(chalk.blue('üîÑ Generating TypeScript types from JSON schemas...'));

    try {
      // Find all schema files
      const schemaFiles = await this.findSchemaFiles();
      console.log(chalk.blue(`üìã Found ${schemaFiles.length} schema files`));

      // Ensure output directory exists
      await fs.mkdir(this.config.output.typeDir, { recursive: true });

      // Process schemas in dependency order
      const processedFiles = await this.processSchemasInOrder(schemaFiles);

      // Generate index file
      await this.generateIndexFile(processedFiles);

      // Generate validators if enabled
      if (this.config.automation.generateValidators) {
        await this.generateValidators(processedFiles);
      }

      // Generate examples if enabled
      if (this.config.automation.generateExamples) {
        await this.generateExamples(processedFiles);
      }

      console.log(chalk.green(`‚úÖ Successfully generated types for ${processedFiles.length} schemas`));

    } catch (error) {
      console.error(chalk.red('‚ùå Type generation failed:'), error);
      throw error;
    }
  }

  async generateType(schemaPath: string): Promise<string> {
    try {
      console.log(chalk.blue(`üîÑ Processing schema: ${schemaPath}`));

      // Load and validate schema
      const schema = await this.loadAndValidateSchema(schemaPath);

      // Generate TypeScript interface
      const typescript = await this.compileSchema(schema, schemaPath);

      // Format with prettier
      const formattedCode = await this.formatTypeScript(typescript);

      // Write to output file
      const outputPath = await this.writeTypeFile(schemaPath, formattedCode);

      console.log(chalk.green(`‚úÖ Generated: ${outputPath}`));
      return outputPath;

    } catch (error) {
      console.error(chalk.red(`‚ùå Failed to generate type for ${schemaPath}:`), error);
      throw error;
    }
  }

  private async findSchemaFiles(): Promise<string[]> {
    const patterns = this.config.input.patterns.map(pattern => 
      path.join(this.config.input.schemaDir, pattern)
    );

    const files: string[] = [];
    for (const pattern of patterns) {
      const matched = await glob(pattern, {
        ignore: this.config.input.exclude
      });
      files.push(...matched);
    }

    // Remove duplicates and sort
    return [...new Set(files)].sort();
  }

  private async loadAndValidateSchema(schemaPath: string): Promise<any> {
    // Check cache first
    if (this.schemaCache.has(schemaPath)) {
      return this.schemaCache.get(schemaPath);
    }

    try {
      const schemaContent = await fs.readFile(schemaPath, 'utf-8');
      const schema = JSON.parse(schemaContent);

      // Validate schema structure if enabled
      if (this.config.validation.validateSchema) {
        await this.validateSchemaStructure(schema, schemaPath);
      }

      // Cache the schema
      this.schemaCache.set(schemaPath, schema);
      return schema;

    } catch (error) {
      throw new Error(`Failed to load schema ${schemaPath}: ${error.message}`);
    }
  }

  private async validateSchemaStructure(schema: any, schemaPath: string): Promise<void> {
    // Basic schema validation
    if (!schema || typeof schema !== 'object') {
      throw new Error(`Invalid schema structure in ${schemaPath}`);
    }

    // Check for required properties
    if (!schema.$schema && !schema.type && !schema.properties && !schema.definitions) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Schema ${schemaPath} may be incomplete - missing $schema, type, properties, or definitions`));
    }

    // Validate against meta-schema if $schema is provided
    if (schema.$schema) {
      try {
        const metaSchema = await this.loadMetaSchema(schema.$schema);
        const validate = this.ajv.compile(metaSchema);
        const valid = validate(schema);
        
        if (!valid) {
          const errors = validate.errors?.map(err => 
            `${err.instancePath}: ${err.message}`
          ).join(', ');
          throw new Error(`Schema validation failed: ${errors}`);
        }
      } catch (error) {
        console.warn(chalk.yellow(`‚ö†Ô∏è  Could not validate schema against meta-schema: ${error.message}`));
      }
    }
  }

  private async loadMetaSchema(schemaUrl: string): Promise<any> {
    // For common meta-schemas, return cached versions
    const commonMetaSchemas: Record<string, any> = {
      'http://json-schema.org/draft-07/schema#': require('ajv/lib/refs/json-schema-draft-07.json'),
      'http://json-schema.org/draft-06/schema#': require('ajv/lib/refs/json-schema-draft-06.json'),
      'https://json-schema.org/draft/2019-09/schema': require('ajv/lib/refs/json-schema-draft-07.json'), // Fallback
    };

    if (commonMetaSchemas[schemaUrl]) {
      return commonMetaSchemas[schemaUrl];
    }

    // For custom meta-schemas, you might want to fetch them
    throw new Error(`Unknown meta-schema: ${schemaUrl}`);
  }

  private async compileSchema(schema: any, schemaPath: string): Promise<string> {
    const options = {
      bannerComment: this.config.compilation.bannerComment,
      style: this.config.compilation.style,
      strictIndexSignatures: this.config.compilation.strictIndexSignatures,
      unknownAny: this.config.compilation.unknownAny,
      unreachableDefinitions: this.config.compilation.unreachableDefinitions,
      enableConstEnums: this.config.compilation.enableConstEnums,
      cwd: path.dirname(schemaPath),
      $refOptions: {
        resolve: {
          file: {
            order: 1,
            read: async (file: any) => {
              const filePath = path.resolve(path.dirname(schemaPath), file.url);
              return fs.readFile(filePath, 'utf-8');
            }
          }
        }
      }
    };

    return await compile(schema, schema.title || this.getSchemaName(schemaPath), options);
  }

  private getSchemaName(schemaPath: string): string {
    const basename = path.basename(schemaPath, '.json');
    const schemaName = basename.replace(/\.schema$/, '');
    
    // Convert to PascalCase
    return schemaName
      .split(/[-_\s]+/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  private async formatTypeScript(code: string): Promise<string> {
    try {
      const prettierConfig = await prettier.resolveConfig(process.cwd()) || {};
      
      return prettier.format(code, {
        parser: 'typescript',
        ...prettierConfig,
        ...this.config.compilation.style
      });
    } catch (error) {
      console.warn(chalk.yellow('‚ö†Ô∏è  Could not format with prettier, using raw output'));
      return code;
    }
  }

  private async writeTypeFile(schemaPath: string, typescript: string): Promise<string> {
    const schemaName = this.getSchemaName(schemaPath);
    const outputFileName = `${schemaName}.ts`;
    const outputPath = path.join(this.config.output.typeDir, outputFileName);

    await fs.writeFile(outputPath, typescript);

    // Generate declaration map if enabled
    if (this.config.output.declarationMaps) {
      const mapPath = outputPath.replace('.ts', '.d.ts.map');
      const sourceMap = this.generateSourceMap(schemaPath, outputPath);
      await fs.writeFile(mapPath, JSON.stringify(sourceMap, null, 2));
    }

    return outputPath;
  }

  private generateSourceMap(schemaPath: string, outputPath: string): any {
    return {
      version: 3,
      file: path.basename(outputPath).replace('.ts', '.d.ts'),
      sourceRoot: '',
      sources: [path.relative(path.dirname(outputPath), schemaPath)],
      names: [],
      mappings: 'AAAA' // Basic mapping
    };
  }

  private async processSchemasInOrder(schemaFiles: string[]): Promise<Array<{ schemaPath: string; outputPath: string; typeName: string }>> {
    const results: Array<{ schemaPath: string; outputPath: string; typeName: string }> = [];

    // Simple dependency resolution - process files in alphabetical order
    // In a real implementation, you'd analyze $ref dependencies
    for (const schemaFile of schemaFiles) {
      try {
        const outputPath = await this.generateType(schemaFile);
        const typeName = this.getSchemaName(schemaFile);
        
        results.push({
          schemaPath: schemaFile,
          outputPath,
          typeName
        });
      } catch (error) {
        console.error(chalk.red(`‚ùå Failed to process ${schemaFile}:`), error);
        // Continue with other files
      }
    }

    return results;
  }

  private async generateIndexFile(processedFiles: Array<{ schemaPath: string; outputPath: string; typeName: string }>): Promise<void> {
    const indexPath = path.join(this.config.output.typeDir, this.config.output.indexFile);

    const exports = processedFiles.map(({ outputPath, typeName }) => {
      const relativePath = path.relative(path.dirname(indexPath), outputPath).replace(/\.ts$/, '');
      return `export type { ${typeName} } from './${relativePath}';`;
    });

    const indexContent = `${this.config.compilation.bannerComment}

// Auto-generated index file for all types
${exports.join('\n')}

// Re-export all types as a namespace
export type AllTypes = {
${processedFiles.map(({ typeName }) => `  ${typeName}: ${typeName};`).join('\n')}
};
`;

    await fs.writeFile(indexPath, await this.formatTypeScript(indexContent));
    console.log(chalk.blue(`üìù Generated index file: ${indexPath}`));
  }

  private async generateValidators(processedFiles: Array<{ schemaPath: string; outputPath: string; typeName: string }>): Promise<void> {
    const validatorsDir = path.join(this.config.output.typeDir, 'validators');
    await fs.mkdir(validatorsDir, { recursive: true });

    for (const { schemaPath, typeName } of processedFiles) {
      try {
        const schema = await this.loadAndValidateSchema(schemaPath);
        const validatorCode = await this.generateValidatorCode(schema, typeName);
        const validatorPath = path.join(validatorsDir, `${typeName}Validator.ts`);
        
        await fs.writeFile(validatorPath, validatorCode);
        console.log(chalk.gray(`  üìã Generated validator: ${validatorPath}`));
      } catch (error) {
        console.warn(chalk.yellow(`‚ö†Ô∏è  Could not generate validator for ${typeName}: ${error.message}`));
      }
    }
  }

  private async generateValidatorCode(schema: any, typeName: string): Promise<string> {
    const validatorCode = `${this.config.compilation.bannerComment}

import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import type { ${typeName} } from '../${typeName}';

// Initialize AJV with formats
const ajv = new Ajv({ allErrors: true, strict: true });
addFormats(ajv);

// Schema definition
const schema = ${JSON.stringify(schema, null, 2)};

// Compiled validator
const validateSchema = ajv.compile<${typeName}>(schema);

/**
 * Validates data against the ${typeName} schema
 * @param data - Data to validate
 * @returns Validation result with typed data or errors
 */
export function validate${typeName}(data: unknown): 
  | { valid: true; data: ${typeName}; errors: null }
  | { valid: false; data: null; errors: string[] } {
  
  const isValid = validateSchema(data);
  
  if (isValid) {
    return { valid: true, data: data as ${typeName}, errors: null };
  } else {
    const errors = validateSchema.errors?.map(error => 
      \`\${error.instancePath}: \${error.message}\`
    ) || ['Unknown validation error'];
    
    return { valid: false, data: null, errors };
  }
}

/**
 * Type guard for ${typeName}
 * @param data - Data to check
 * @returns True if data is valid ${typeName}
 */
export function is${typeName}(data: unknown): data is ${typeName} {
  return validateSchema(data);
}

/**
 * Validates and throws if invalid
 * @param data - Data to validate
 * @returns Validated data
 * @throws Error if validation fails
 */
export function assert${typeName}(data: unknown): ${typeName} {
  const result = validate${typeName}(data);
  if (!result.valid) {
    throw new Error(\`Invalid ${typeName}: \${result.errors.join(', ')}\`);
  }
  return result.data;
}
`;

    return this.formatTypeScript(validatorCode);
  }

  private async generateExamples(processedFiles: Array<{ schemaPath: string; outputPath: string; typeName: string }>): Promise<void> {
    const examplesDir = path.join(this.config.output.typeDir, 'examples');
    await fs.mkdir(examplesDir, { recursive: true });

    for (const { schemaPath, typeName } of processedFiles) {
      try {
        const schema = await this.loadAndValidateSchema(schemaPath);
        const exampleCode = await this.generateExampleCode(schema, typeName);
        const examplePath = path.join(examplesDir, `${typeName}Example.ts`);
        
        await fs.writeFile(examplePath, exampleCode);
        console.log(chalk.gray(`  üìÑ Generated example: ${examplePath}`));
      } catch (error) {
        console.warn(chalk.yellow(`‚ö†Ô∏è  Could not generate example for ${typeName}: ${error.message}`));
      }
    }
  }

  private async generateExampleCode(schema: any, typeName: string): Promise<string> {
    const example = this.generateExampleData(schema);
    
    const exampleCode = `${this.config.compilation.bannerComment}

import type { ${typeName} } from '../${typeName}';

/**
 * Example data for ${typeName}
 * Generated from the JSON schema
 */
export const example${typeName}: ${typeName} = ${JSON.stringify(example, null, 2)};

/**
 * Multiple examples for different use cases
 */
export const ${typeName.toLowerCase()}Examples = {
  basic: example${typeName},
  // Add more examples as needed
};
`;

    return this.formatTypeScript(exampleCode);
  }

  private generateExampleData(schema: any): any {
    // Simple example generation - in real implementation you'd use a library like json-schema-faker
    if (schema.type === 'object' && schema.properties) {
      const example: any = {};
      
      for (const [key, propSchema] of Object.entries(schema.properties)) {
        example[key] = this.generateExampleValue(propSchema as any);
      }
      
      return example;
    }
    
    return this.generateExampleValue(schema);
  }

  private generateExampleValue(schema: any): any {
    if (schema.example !== undefined) {
      return schema.example;
    }
    
    if (schema.default !== undefined) {
      return schema.default;
    }
    
    switch (schema.type) {
      case 'string':
        return schema.enum ? schema.enum[0] : 'example';
      case 'number':
      case 'integer':
        return schema.minimum || 0;
      case 'boolean':
        return true;
      case 'array':
        return schema.items ? [this.generateExampleValue(schema.items)] : [];
      case 'object':
        return this.generateExampleData(schema);
      default:
        return null;
    }
  }
}

// CLI and automation utilities
export const typeScripts = {
  "types:generate": "tsx scripts/generate-types.ts",
  "types:watch": "nodemon --watch schemas --ext json --exec 'npm run types:generate'",
  "types:validate": "tsx scripts/validate-schemas.ts",
  "types:clean": "rimraf src/types"
};

// Export service for programmatic use
export { TypeGenerationService, type TypeGenerationConfig };

// CLI entry point
async function main() {
  const config: Partial<TypeGenerationConfig> = {
    input: {
      schemaDir: './schemas',
      patterns: ['**/*.json'],
      exclude: ['node_modules/**']
    },
    output: {
      typeDir: './src/types/generated',
      indexFile: 'index.ts',
      declarationMaps: true
    },
    automation: {
      generateValidators: true,
      generateExamples: true
    }
  };

  const service = new TypeGenerationService(config);

  try {
    await service.generateAllTypes();
    console.log(chalk.green('\nüéâ Type generation completed successfully!'));
  } catch (error) {
    console.error(chalk.red('\nüí• Type generation failed:'), error);
    process.exit(1);
  }
}

if (require.main === module) {
  main().catch(console.error);
}</correct-example>
          <incorrect-example title="Poor type generation without proper configuration" conditions="Generating TypeScript types from JSON Schema" expected-result="Type-safe, validated TypeScript types with proper tooling integration" incorrectness-criteria="No configuration, basic usage only, no validation, no automation, poor error handling">const { compile } = require('json-schema-to-typescript');

// Bad: No configuration, basic usage only
async function badTypeGeneration() {
  // Bad: Hardcoded schema
  const schema = {
    type: 'object',
    properties: {
      name: { type: 'string' }
    }
  };
  
  // Bad: No error handling
  const ts = await compile(schema, 'MyType');
  
  // Bad: No file management
  console.log(ts);
  
  // Bad: No validation
  // Bad: No automation
  // Bad: No formatting
}

// Bad: No batch processing
// Bad: No dependency resolution
// Bad: No index generation
// Bad: No validators</incorrect-example>
        </example>
      </examples>
    </non-negotiable>
  </requirements>
</rule>
