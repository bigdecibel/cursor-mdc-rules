---
description: Modern React development patterns using functional components, hooks, and TypeScript
globs: "*.{jsx,tsx}"
alwaysApply: false
---

<rule>
  <meta>
    <title>React Best Practices</title>
    <description>Modern React development patterns using functional components, hooks, and TypeScript</description>
    <created-at utc-timestamp="1744240920">January 25, 2025, 10:15 AM AEST</created-at>
    <last-updated-at utc-timestamp="1744240920">January 25, 2025, 10:15 AM AEST</last-updated-at>
    <applies-to>
      <file-matcher glob="*.{jsx,tsx}">React component files with JSX or TSX extension</file-matcher>
      <action-matcher action="react-development">Triggered when developing React components</action-matcher>
    </applies-to>
  </meta>
  <requirements>
    <non-negotiable priority="critical">
      <description>Use functional components with hooks instead of class components. All new components must be functional.</description>
      <examples>
        <example title="Component Structure">
          <correct-example title="Functional component with hooks" conditions="Creating a new React component" expected-result="Modern functional component" correctness-criteria="Uses functional component with hooks"><![CDATA[import React, { useState, useEffect } from 'react';

interface UserProfileProps {
  userId: string;
  onUpdate?: (user: User) => void;
}

const UserProfile: React.FC<UserProfileProps> = ({ userId, onUpdate }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser(userId).then(setUser).finally(() => setLoading(false));
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
};

export default UserProfile;]]></correct-example>
          <incorrect-example title="Class component" conditions="Creating a new React component" expected-result="Modern functional component" incorrectness-criteria="Uses deprecated class component pattern"><![CDATA[import React, { Component } from 'react';

class UserProfile extends Component<UserProfileProps, UserProfileState> {
  constructor(props: UserProfileProps) {
    super(props);
    this.state = {
      user: null,
      loading: true
    };
  }

  componentDidMount() {
    fetchUser(this.props.userId)
      .then(user => this.setState({ user, loading: false }));
  }

  render() {
    const { user, loading } = this.state;
    if (loading) return <div>Loading...</div>;
    if (!user) return <div>User not found</div>;

    return (
      <div className="user-profile">
        <h2>{user.name}</h2>
        <p>{user.email}</p>
      </div>
    );
  }
}]]></incorrect-example>
        </example>
      </examples>
    </non-negotiable>
    <non-negotiable priority="critical">
      <description>Use TypeScript for all React components. Define proper interfaces for props and state.</description>
      <examples>
        <example title="TypeScript Integration">
          <correct-example title="Proper TypeScript interfaces" conditions="Defining component props" expected-result="Type-safe component" correctness-criteria="Uses TypeScript interfaces for props"><![CDATA[interface ButtonProps {
  variant: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  onClick: () => void;
  children: React.ReactNode;
}

const Button: React.FC<ButtonProps> = ({
  variant,
  size = 'medium',
  disabled = false,
  onClick,
  children
}) => {
  return (
    <button
      className={`btn btn-${variant} btn-${size}`}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
};]]></correct-example>
          <incorrect-example title="Missing TypeScript types" conditions="Defining component props" expected-result="Type-safe component" incorrectness-criteria="Lacks proper TypeScript interfaces"><![CDATA[const Button = ({ variant, size, disabled, onClick, children }) => {
  return (
    <button
      className={`btn btn-${variant} btn-${size}`}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
};]]></incorrect-example>
        </example>
      </examples>
    </non-negotiable>
    <requirement priority="high">
      <description>Use custom hooks to extract reusable logic from components. Keep components focused on rendering.</description>
      <examples>
        <example title="Custom Hook Usage">
          <correct-example title="Extracted custom hook" conditions="Managing component state" expected-result="Reusable logic separated from component" correctness-criteria="Uses custom hook for state management"><![CDATA[// useUser.ts
export const useUser = (userId: string) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchUser(userId)
      .then(setUser)
      .catch(err => setError(err.message))
      .finally(() => setLoading(false));
  }, [userId]);

  return { user, loading, error };
};

// UserProfile.tsx
const UserProfile: React.FC<UserProfileProps> = ({ userId }) => {
  const { user, loading, error } = useUser(userId);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
};]]></correct-example>
          <incorrect-example title="Logic mixed in component" conditions="Managing component state" expected-result="Reusable logic separated from component" incorrectness-criteria="State management logic embedded in component"><![CDATA[const UserProfile: React.FC<UserProfileProps> = ({ userId }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchUser(userId)
      .then(setUser)
      .catch(err => setError(err.message))
      .finally(() => setLoading(false));
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
};]]></incorrect-example>
        </example>
      </examples>
    </requirement>
    <requirement priority="high">
      <description>Use React.memo for performance optimization when components receive stable props and render expensive content.</description>
      <examples>
        <example title="Performance Optimization">
          <correct-example title="Memoized component" conditions="Optimizing expensive components" expected-result="Performance optimized component" correctness-criteria="Uses React.memo for stable props"><![CDATA[interface ExpensiveChartProps {
  data: ChartData[];
  width: number;
  height: number;
}

const ExpensiveChart: React.FC<ExpensiveChartProps> = React.memo(({ data, width, height }) => {
  // Expensive chart rendering logic
  return (
    <svg width={width} height={height}>
      {/* Chart rendering */}
    </svg>
  );
});

ExpensiveChart.displayName = 'ExpensiveChart';]]></correct-example>
          <incorrect-example title="Unoptimized component" conditions="Optimizing expensive components" expected-result="Performance optimized component" incorrectness-criteria="Lacks memoization for expensive rendering"><![CDATA[const ExpensiveChart: React.FC<ExpensiveChartProps> = ({ data, width, height }) => {
  // Expensive chart rendering logic
  return (
    <svg width={width} height={height}>
      {/* Chart rendering */}
    </svg>
  );
};]]></incorrect-example>
        </example>
      </examples>
    </requirement>
    <requirement priority="high">
      <description>Use proper dependency arrays in useEffect hooks. Include all dependencies that the effect uses.</description>
      <examples>
        <example title="useEffect Dependencies">
          <correct-example title="Complete dependency array" conditions="Setting up useEffect hook" expected-result="Properly configured effect" correctness-criteria="Includes all dependencies used in effect"><![CDATA[const UserProfile: React.FC<UserProfileProps> = ({ userId, onUpdate }) => {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    fetchUser(userId).then(userData => {
      setUser(userData);
      onUpdate?.(userData);
    });
  }, [userId, onUpdate]); // Include all dependencies

  // Component logic
};]]></correct-example>
          <incorrect-example title="Missing dependencies" conditions="Setting up useEffect hook" expected-result="Properly configured effect" incorrectness-criteria="Missing dependencies in array"><![CDATA[const UserProfile: React.FC<UserProfileProps> = ({ userId, onUpdate }) => {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    fetchUser(userId).then(userData => {
      setUser(userData);
      onUpdate?.(userData); // onUpdate used but not in dependencies
    });
  }, [userId]); // Missing onUpdate dependency

  // Component logic
};]]></incorrect-example>
        </example>
      </examples>
    </requirement>
    <requirement priority="medium">
      <description>Use descriptive component and prop names. Follow PascalCase for components and camelCase for props.</description>
      <examples>
        <example title="Naming Conventions">
          <correct-example title="Proper naming" conditions="Naming components and props" expected-result="Clear, descriptive names" correctness-criteria="Uses PascalCase for components, camelCase for props"><![CDATA[interface UserProfileCardProps {
  userData: User;
  onEditClick: () => void;
  showActions: boolean;
}

const UserProfileCard: React.FC<UserProfileCardProps> = ({
  userData,
  onEditClick,
  showActions
}) => {
  return (
    <div className="user-profile-card">
      <h3>{userData.name}</h3>
      {showActions && (
        <button onClick={onEditClick}>Edit Profile</button>
      )}
    </div>
  );
};]]></correct-example>
          <incorrect-example title="Poor naming" conditions="Naming components and props" expected-result="Clear, descriptive names" incorrectness-criteria="Uses unclear or inconsistent naming"><![CDATA[interface Props {
  data: User;
  click: () => void;
  show: boolean;
}

const Card: React.FC<Props> = ({ data, click, show }) => {
  return (
    <div className="card">
      <h3>{data.name}</h3>
      {show && (
        <button onClick={click}>Edit</button>
      )}
    </div>
  );
};]]></incorrect-example>
        </example>
      </examples>
    </requirement>
    <requirement priority="medium">
      <description>Use proper error boundaries to catch and handle errors in component trees.</description>
      <examples>
        <example title="Error Boundaries">
          <correct-example title="Error boundary component" conditions="Handling component errors" expected-result="Graceful error handling" correctness-criteria="Uses error boundary pattern"><![CDATA[interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends React.Component<
  React.PropsWithChildren<{}>,
  ErrorBoundaryState
> {
  constructor(props: React.PropsWithChildren<{}>) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <p>{this.state.error?.message}</p>
        </div>
      );
    }

    return this.props.children;
  }
}]]></correct-example>
          <incorrect-example title="No error handling" conditions="Handling component errors" expected-result="Graceful error handling" incorrectness-criteria="Lacks error boundary protection"><![CDATA[const App: React.FC = () => {
  return (
    <div className="app">
      <UserProfile userId="123" />
      <ExpensiveChart data={chartData} />
      {/* No error boundary - errors will crash the app */}
    </div>
  );
};]]></incorrect-example>
        </example>
      </examples>
    </requirement>
  </requirements>
  <grammar>
    <grammar-entry title="Component Structure">
      <pattern description="Functional component with TypeScript">^import React.*from 'react';\s*\n\ninterface \w+Props \{[^}]*\}\s*\n\nconst \w+: React\.FC<\w+Props> = \(.*\) => \{[\s\S]*\};</pattern>
      <example description="Standard functional component">import React, { useState, useEffect } from 'react';

interface ComponentProps {
  prop1: string;
  prop2?: number;
}

const Component: React.FC<ComponentProps> = ({ prop1, prop2 }) => {
  const [state, setState] = useState<string>('');
  
  useEffect(() => {
    // Effect logic
  }, [prop1]);

  return <div>{prop1}</div>;
};</example>
    </grammar-entry>
    <grammar-entry title="Hook Usage">
      <pattern description="Custom hook pattern">^export const use\w+ = \(.*\) => \{[\s\S]*\};</pattern>
      <example description="Custom hook structure">export const useCustomHook = (param: string) => {
  const [state, setState] = useState<string>('');
  
  useEffect(() => {
    // Hook logic
  }, [param]);

  return { state, setState };
};</example>
    </grammar-entry>
  </grammar>
  <context description="Modern React development context">
    React has evolved significantly with the introduction of hooks in React 16.8. Functional components with hooks are now the preferred approach over class components. This rule focuses on modern React patterns that promote better performance, maintainability, and developer experience. TypeScript integration is strongly recommended for better type safety and developer tooling.
  </context>
  <references>
    <reference as="dependency" href=".cursor/rules/rules.mdc" reason="Follows standard rule format">Base rule format definition</reference>
    <reference as="context" href=".cursor/rules/typescript.mdc" reason="TypeScript integration">TypeScript best practices for React</reference>
  </references>
</rule>
